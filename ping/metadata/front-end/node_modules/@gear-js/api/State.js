import '@polkadot/types';
import 'assert';
import '@polkadot/util';
import { CreateType } from './metadata/create-type.js';
import { MetadataVersion } from './metadata/programMetadata.js';
import { GearProgramStorage } from './Storage.js';
import './utils/generate.js';
import './utils/prefixes.js';
import './utils/separator.js';
import '@polkadot/api';
import '@polkadot/util-crypto';
import { encodePayload } from './utils/create-payload.js';

class GearProgramState extends GearProgramStorage {
    /**
     * ## Read state using meta wasm file
     * @param args
     * @param meta StateMetadata returned from getStateMetadata function
     */
    async readUsingWasm(params, stateMeta, programMeta) {
        const fnTypes = stateMeta?.functions[params.fn_name];
        const argument = fnTypes?.input !== undefined && fnTypes?.input !== null
            ? Array.from(stateMeta.createType(fnTypes.input, params.argument).toU8a())
            : null;
        const payload = programMeta.version === MetadataVersion.V2Rust ? encodePayload(params.payload, programMeta, 'state') : [];
        const code = typeof params.wasm === 'string' ? params.wasm : CreateType.create('Bytes', Array.from(params.wasm));
        const state = await this._api.rpc.gear.readStateUsingWasm(params.programId, payload, params.fn_name, code, argument, params.at);
        return stateMeta && fnTypes ? stateMeta.createType(fnTypes.output, state) : state;
    }
    /**
     * ### Read state of program (calls `gear_readState` rpc call)
     * @param args ProgramId, payload and hash of block where it's necessary to read state (optional)
     * @param meta (optional) Program metadata returned from `ProgramMetadata.from` method. If not specified, payload will be sent and state will be returned as `Bytes`
     * @param type (optional) Index of type to decode state. metadata.types.state.input is uesd by default
     *
     * @example
     * const meta = ProgramMetadata.from('0x...');
     * const programId = '0x...';
     *
     * const result = await api.programState.read({ programId, payload: { id: 1 } }, meta);
     * console.log(result.toJSON());
     */
    async read(args, meta, type) {
        const payload = meta
            ? meta.version === MetadataVersion.V2Rust
                ? encodePayload(args.payload, meta, 'state', type)
                : []
            : args.payload;
        const state = await this._api.rpc.gear.readState(args.programId, payload, args.at || null);
        if (!meta) {
            return state;
        }
        if (type !== undefined) {
            return meta.createType(type, state);
        }
        if (meta.version === MetadataVersion.V1Rust) {
            return meta.createType(meta.types.state, state);
        }
        return meta.createType(meta.types.state.output, state);
    }
    async readBatch(args) {
        return this._api.rpc.gear.readStateBatch(args.idPayloadBatch, args.at || null);
    }
}

export { GearProgramState };
