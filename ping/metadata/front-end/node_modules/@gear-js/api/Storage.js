import { u8aToU8a } from '@polkadot/util';
import { ProgramDoesNotExistError, ProgramTerminatedError, ProgramExitedError, PausedProgramDoesNotExistError } from './errors/program.errors.js';
import { SPEC_VERSION } from './consts.js';

class GearProgramStorage {
    _api;
    constructor(_api) {
        this._api = _api;
    }
    /**
     * ### Get program from chain
     * @param id Program id
     * @param at _(optional)_ Hash of block to query at
     * @returns
     */
    async getProgram(id, at) {
        const api = at ? await this._api.at(at) : this._api;
        const programOption = (await api.query.gearProgram.programStorage(id));
        if (programOption.isNone) {
            throw new ProgramDoesNotExistError(id);
        }
        const program = programOption.unwrap();
        if (program.isTerminated)
            throw new ProgramTerminatedError(program.asTerminated.toHex());
        if (program.isExited)
            throw new ProgramExitedError(program.asExited.toHex());
        return program.asActive;
    }
    /**
     * Get list of pages for program
     * @param programId
     * @param gProg
     * @returns
     */
    async getProgramPages(programId, program, at) {
        const pages = {};
        const query = this._api.specVersion >= SPEC_VERSION.V1100
            ? this._api.query.gearProgram.memoryPages
            : this._api.query.gearProgram.memoryPageStorage;
        const args = this._api.specVersion >= SPEC_VERSION.V1100 ? [programId, program.memoryInfix] : [programId];
        for (const [start, end] of program.pagesWithData.inner) {
            for (let page = start.toNumber(); page <= end.toNumber(); page++) {
                pages[page] = u8aToU8a(await this._api.provider.send('state_getStorage', [query.key(...args, page), at]));
            }
        }
        return pages;
    }
    /**
     * ### Get block number and hash of paused program
     * @param id paused program id
     * @param at _(optional)_ Hash of block to query at
     * @returns
     */
    async getPausedProgramHashAndBlockNumber(id, at) {
        const storageOption = (await this._api.query.gearProgram.pausedProgramStorage(id, at));
        if (storageOption.isNone) {
            throw new PausedProgramDoesNotExistError(id);
        }
        const storage = storageOption.unwrap();
        return {
            blockNumber: storage[0],
            hash: storage[1],
        };
    }
}

export { GearProgramStorage };
