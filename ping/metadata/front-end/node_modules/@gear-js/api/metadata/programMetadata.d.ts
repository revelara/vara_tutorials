import { HumanProgramMetadataReprRustV1, HumanProgramMetadataReprRustV2 } from '../types';
import { GearMetadata } from './metadata';
export declare enum Lang {
    RUST = 0
}
export declare enum MetadataVersion {
    V1Rust = 1,
    V2Rust = 2
}
export declare class ProgramMetadata extends GearMetadata {
    types: Omit<HumanProgramMetadataReprRustV1, 'reg'> | Omit<HumanProgramMetadataReprRustV2, 'reg'>;
    lang: Lang;
    version: MetadataVersion;
    constructor(metadata: Uint8Array, lang: number, version: number);
    /**
     * ### Get `ProgramMetadata` instance from metadata in hex format
     * Since we've started to support different versions of metadata generated when compilng a program written in Rust
     * it may be necessary to check what the version is. This can be obtained from the `metadata.version` field of `ProgramMetadata` class.
     *
     *
     * This will help to understand what types the metadata contains. For instance, metadata V1 has a `state` field
     * thath describes the type of the output of the `state` function. However, in metadata V2, the `state` field includes 2 types: `input` and `output`.
     * This change was made because starting from this version, the program expects input for the state function.
     * @param hexMetadata metadata generated during program compilation
     *
     * @example
     * import { ProgramMetada, MetadataVersion } from '@gear-js/api';
     *
     * const metaHex = '0x...';
     * const meta = ProgramMetadata.from(metaHex);
     *
     * // State decoding
     * const someBytes = '0x...';
     *
     * if (meta.version === MetadataVersion.V1Rust) {
     *   const result = CreateType.create(meta.types.state, somBytes).toJSON();
     * } else {
     *   const result = CreateType.create(meta.types.state.output, someBytes).toJSON();
     * }
     *
     */
    static from(hexMetadata: string): ProgramMetadata;
}
