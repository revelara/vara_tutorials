import { hexToU8a } from '@polkadot/util';
import { CreateType } from './create-type.js';
import { GearMetadata } from './metadata.js';

var Lang;
(function (Lang) {
    Lang[Lang["RUST"] = 0] = "RUST";
})(Lang || (Lang = {}));
var MetadataVersion;
(function (MetadataVersion) {
    MetadataVersion[MetadataVersion["V1Rust"] = 1] = "V1Rust";
    MetadataVersion[MetadataVersion["V2Rust"] = 2] = "V2Rust";
})(MetadataVersion || (MetadataVersion = {}));
var MetadataTypeName;
(function (MetadataTypeName) {
    MetadataTypeName["V1Rust"] = "ProgramMetadataReprRustV1";
    MetadataTypeName["V2Rust"] = "ProgramMetadataReprRustV2";
})(MetadataTypeName || (MetadataTypeName = {}));
function getMetadataTypeName(version) {
    switch (version) {
        case MetadataVersion.V1Rust:
            return MetadataTypeName.V1Rust;
        case MetadataVersion.V2Rust:
            return MetadataTypeName.V2Rust;
        default:
            throw new Error('Metadata: Invalid metadata version');
    }
}
class ProgramMetadata extends GearMetadata {
    types;
    lang;
    version;
    constructor(metadata, lang, version) {
        let metaRepr;
        if (lang === Lang.RUST) {
            try {
                metaRepr = CreateType.create(getMetadataTypeName(version), metadata);
            }
            catch (err) {
                throw new Error('Metadata: Invalid metadata');
            }
        }
        else {
            throw new Error('Metadata: Unsupported lang');
        }
        const { reg, ...types } = version === MetadataVersion.V1Rust
            ? metaRepr.toJSON()
            : metaRepr.toJSON();
        super(reg);
        this.version = version;
        this.lang = lang;
        this.types = types;
    }
    /**
     * ### Get `ProgramMetadata` instance from metadata in hex format
     * Since we've started to support different versions of metadata generated when compilng a program written in Rust
     * it may be necessary to check what the version is. This can be obtained from the `metadata.version` field of `ProgramMetadata` class.
     *
     *
     * This will help to understand what types the metadata contains. For instance, metadata V1 has a `state` field
     * thath describes the type of the output of the `state` function. However, in metadata V2, the `state` field includes 2 types: `input` and `output`.
     * This change was made because starting from this version, the program expects input for the state function.
     * @param hexMetadata metadata generated during program compilation
     *
     * @example
     * import { ProgramMetada, MetadataVersion } from '@gear-js/api';
     *
     * const metaHex = '0x...';
     * const meta = ProgramMetadata.from(metaHex);
     *
     * // State decoding
     * const someBytes = '0x...';
     *
     * if (meta.version === MetadataVersion.V1Rust) {
     *   const result = CreateType.create(meta.types.state, somBytes).toJSON();
     * } else {
     *   const result = CreateType.create(meta.types.state.output, someBytes).toJSON();
     * }
     *
     */
    static from(hexMetadata) {
        if (!hexMetadata.startsWith('0x')) {
            hexMetadata = '0x' + hexMetadata;
        }
        const u8aMeta = hexToU8a(hexMetadata);
        const lang = CreateType.create('u8', u8aMeta[0]).toNumber();
        const version = CreateType.create('u16', u8aMeta.slice(1, 3)).toNumber();
        return new ProgramMetadata(u8aMeta.slice(3), lang, version);
    }
}

export { Lang, MetadataVersion, ProgramMetadata };
