import { u8aToHex } from '@polkadot/util';
import { generateCodeHash } from './utils/generate.js';
import { getIdsFromKeys } from './utils/prefixes.js';
import './utils/separator.js';
import { validateCodeId } from './utils/validate.js';
import '@polkadot/api';
import '@polkadot/util-crypto';
import '@polkadot/types';
import 'assert';
import './default/index.js';
import './metadata/programMetadata.js';
import { CodeDoesNotExistError } from './errors/program.errors.js';
import { GearTransaction } from './Transaction.js';
import { getGrReply } from './wasm/reply.js';

class GearCode extends GearTransaction {
    /**
     * ### Submit code without initialization
     * @param code
     * @returns Code hash
     */
    async upload(code) {
        const codeHash = generateCodeHash(code);
        await validateCodeId(codeHash, this._api);
        const codeBytes = this._api.createType('Bytes', Array.from(code));
        this.extrinsic = this._api.tx.gear.uploadCode(codeBytes);
        return { codeHash, submitted: this.extrinsic, extrinsic: this.extrinsic };
    }
    /**
     * ### Check that codeId exists on chain
     * @param codeId
     */
    async exists(codeId) {
        const codeMetadata = (await this._api.query.gearProgram.metadataStorage(codeId));
        return codeMetadata.isSome;
    }
    /**
     * ### Get code storage
     * @param codeId
     */
    async storage(codeId) {
        return this._api.query.gearProgram.codeStorage(codeId);
    }
    /**
     * ### Get static pages of code
     * @param codeId
     */
    async staticPages(codeId) {
        const storage = await this.storage(codeId);
        return storage.isSome ? storage.unwrap().staticPages.toNumber() : null;
    }
    /**
     * ### Get all ids of codes uploaded on connected chain
     * @returns array of code ids uploaded on chain
     */
    async all() {
        const prefix = this._api.query.gearProgram.metadataStorage.keyPrefix();
        const keys = await this._api.rpc.state.getKeys(prefix);
        const codeIds = getIdsFromKeys(keys, prefix);
        return codeIds;
    }
    async metaHash(codeId) {
        const code = (await this._api.query.gearProgram.originalCodeStorage(codeId));
        if (code.isNone) {
            throw new CodeDoesNotExistError(codeId);
        }
        const metahash = await getGrReply(code.unwrap().toHex(), 'metahash');
        return u8aToHex(metahash);
    }
    async metaHashFromWasm(wasm) {
        const metahash = await getGrReply(wasm, 'metahash');
        return u8aToHex(metahash);
    }
}

export { GearCode };
