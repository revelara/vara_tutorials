'use strict';

require('@polkadot/types');
require('assert');
require('@polkadot/util');
var createType = require('./metadata/create-type.js');
var programMetadata = require('./metadata/programMetadata.js');
var Storage = require('./Storage.js');
require('./utils/generate.js');
require('./utils/prefixes.js');
require('./utils/separator.js');
require('@polkadot/api');
require('@polkadot/util-crypto');
var createPayload = require('./utils/create-payload.js');

class GearProgramState extends Storage.GearProgramStorage {
    /**
     * ## Read state using meta wasm file
     * @param args
     * @param meta StateMetadata returned from getStateMetadata function
     */
    async readUsingWasm(params, stateMeta, programMeta) {
        const fnTypes = stateMeta?.functions[params.fn_name];
        const argument = fnTypes?.input !== undefined && fnTypes?.input !== null
            ? Array.from(stateMeta.createType(fnTypes.input, params.argument).toU8a())
            : null;
        const payload = programMeta.version === programMetadata.MetadataVersion.V2Rust ? createPayload.encodePayload(params.payload, programMeta, 'state') : [];
        const code = typeof params.wasm === 'string' ? params.wasm : createType.CreateType.create('Bytes', Array.from(params.wasm));
        const state = await this._api.rpc.gear.readStateUsingWasm(params.programId, payload, params.fn_name, code, argument, params.at);
        return stateMeta && fnTypes ? stateMeta.createType(fnTypes.output, state) : state;
    }
    /**
     * ### Read state of program (calls `gear_readState` rpc call)
     * @param args ProgramId, payload and hash of block where it's necessary to read state (optional)
     * @param meta (optional) Program metadata returned from `ProgramMetadata.from` method. If not specified, payload will be sent and state will be returned as `Bytes`
     * @param type (optional) Index of type to decode state. metadata.types.state.input is uesd by default
     *
     * @example
     * const meta = ProgramMetadata.from('0x...');
     * const programId = '0x...';
     *
     * const result = await api.programState.read({ programId, payload: { id: 1 } }, meta);
     * console.log(result.toJSON());
     */
    async read(args, meta, type) {
        const payload = meta
            ? meta.version === programMetadata.MetadataVersion.V2Rust
                ? createPayload.encodePayload(args.payload, meta, 'state', type)
                : []
            : args.payload;
        const state = await this._api.rpc.gear.readState(args.programId, payload, args.at || null);
        if (!meta) {
            return state;
        }
        if (type !== undefined) {
            return meta.createType(type, state);
        }
        if (meta.version === programMetadata.MetadataVersion.V1Rust) {
            return meta.createType(meta.types.state, state);
        }
        return meta.createType(meta.types.state.output, state);
    }
    async readBatch(args) {
        return this._api.rpc.gear.readStateBatch(args.idPayloadBatch, args.at || null);
    }
}

exports.GearProgramState = GearProgramState;
