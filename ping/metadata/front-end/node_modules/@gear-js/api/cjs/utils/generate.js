'use strict';

var utilCrypto = require('@polkadot/util-crypto');
var util = require('@polkadot/util');
require('@polkadot/types');
require('assert');
var createType = require('../metadata/create-type.js');
require('../metadata/programMetadata.js');
var consts = require('../consts.js');

const VOUCHER_PREFIX_BEFORE_1100 = util.stringToU8a('modlpy/voucher__');
const VOUCHER_PREFIX = util.stringToU8a('voucher');
function generateCodeHash(code) {
    return utilCrypto.blake2AsHex(util.u8aToU8a(code), 256);
}
function generateProgramId(api, codeOrHash, salt) {
    const [code, codeHash] = typeof codeOrHash === 'string' ? [undefined, codeOrHash] : [codeOrHash, undefined];
    const codeHashU8a = codeHash ? util.u8aToU8a(codeHash) : utilCrypto.blake2AsU8a(code, 256);
    const saltU8a = createType.CreateType.create('Vec<u8>', salt).toU8a().slice(1);
    const prefix = api.specVersion >= consts.SPEC_VERSION.V1010 ? 'program_from_user' : 'program';
    const programStrU8a = new TextEncoder().encode(prefix);
    const id = Uint8Array.from([...programStrU8a, ...codeHashU8a, ...saltU8a]);
    return utilCrypto.blake2AsHex(id, 256);
}
function generateVoucherId(nonceOrWho, programId) {
    const [nonce, who] = typeof nonceOrWho === 'string' && programId ? [undefined, nonceOrWho] : [nonceOrWho, undefined];
    if (nonce) {
        const nonceU8a = util.u8aToU8a(nonce);
        const id = Uint8Array.from([...VOUCHER_PREFIX, ...nonceU8a]);
        return utilCrypto.blake2AsHex(id, 256);
    }
    const whoU8a = util.u8aToU8a(who);
    const programU8a = util.u8aToU8a(programId);
    const id = Uint8Array.from([...VOUCHER_PREFIX_BEFORE_1100, ...whoU8a, ...programU8a]);
    return utilCrypto.blake2AsHex(id, 256);
}

exports.generateCodeHash = generateCodeHash;
exports.generateProgramId = generateProgramId;
exports.generateVoucherId = generateVoucherId;
