'use strict';

var util = require('@polkadot/util');
var metadata = require('../metadata/metadata.js');
var createType = require('../metadata/create-type.js');
require('@polkadot/types');
require('assert');
require('../metadata/programMetadata.js');
var is = require('../metadata/is.js');

function getRegistry(metaOrHexRegistry) {
    if (!metaOrHexRegistry) {
        return undefined;
    }
    if (util.isHex(metaOrHexRegistry)) {
        return metaOrHexRegistry;
    }
}
function encodePayload(payload, hexRegistryOrMeta, type, typeIndexOrPayloadType) {
    if (payload === undefined) {
        return [];
    }
    if (util.isHex(payload)) {
        return Array.from(util.hexToU8a(payload));
    }
    if (util.isU8a(payload)) {
        return Array.from(payload);
    }
    const [reg, meta] = is.isProgramMeta(hexRegistryOrMeta)
        ? [undefined, hexRegistryOrMeta]
        : [hexRegistryOrMeta, undefined];
    const [typeIndex, payloadType] = typeof typeIndexOrPayloadType === 'number'
        ? [typeIndexOrPayloadType, undefined]
        : [undefined, typeIndexOrPayloadType];
    let result;
    if (meta) {
        if (typeIndex || typeIndex === 0) {
            result = meta.createType(typeIndex, payload);
        }
        else if (payloadType) {
            const index = meta.getTypeIndexByName(payloadType);
            if (index === null) {
                result = createType.CreateType.create(payloadType, payload);
            }
            else {
                result = meta.createType(meta.getTypeIndexByName(payloadType), payload);
            }
        }
        else {
            const withType = type === 'reply' ? meta.types[type] : meta.types[type].input;
            result = meta.createType(withType, payload);
        }
    }
    else if (reg) {
        if (typeIndex || typeIndex === 0) {
            result = new metadata.GearMetadata(reg).createType(typeIndex, payload);
        }
        else {
            result = createType.CreateType.create(payloadType, payload, reg);
        }
    }
    else if (payloadType) {
        result = createType.CreateType.create(payloadType, payload);
    }
    else {
        result = createType.CreateType.create('Bytes', payload);
    }
    return Array.from(result.toU8a());
}

exports.encodePayload = encodePayload;
exports.getRegistry = getRegistry;
