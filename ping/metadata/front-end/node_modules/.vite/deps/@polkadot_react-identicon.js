"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js
  var require_base64_js = __commonJS({
    "node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js"(exports) {
      "use strict";
      init_dist();
      exports.byteLength = byteLength;
      exports.toByteArray = toByteArray;
      exports.fromByteArray = fromByteArray;
      var lookup = [];
      var revLookup = [];
      var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      for (i = 0, len = code.length; i < len; ++i) {
        lookup[i] = code[i];
        revLookup[code.charCodeAt(i)] = i;
      }
      var i;
      var len;
      revLookup["-".charCodeAt(0)] = 62;
      revLookup["_".charCodeAt(0)] = 63;
      function getLens(b64) {
        var len2 = b64.length;
        if (len2 % 4 > 0) {
          throw new Error("Invalid string. Length must be a multiple of 4");
        }
        var validLen = b64.indexOf("=");
        if (validLen === -1)
          validLen = len2;
        var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
        return [validLen, placeHoldersLen];
      }
      function byteLength(b64) {
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function _byteLength(b64, validLen, placeHoldersLen) {
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function toByteArray(b64) {
        var tmp;
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
        var curByte = 0;
        var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
        var i2;
        for (i2 = 0; i2 < len2; i2 += 4) {
          tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
          arr[curByte++] = tmp >> 16 & 255;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 2) {
          tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 1) {
          tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        return arr;
      }
      function tripletToBase64(num) {
        return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
      }
      function encodeChunk(uint8, start, end) {
        var tmp;
        var output = [];
        for (var i2 = start; i2 < end; i2 += 3) {
          tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
          output.push(tripletToBase64(tmp));
        }
        return output.join("");
      }
      function fromByteArray(uint8) {
        var tmp;
        var len2 = uint8.length;
        var extraBytes = len2 % 3;
        var parts = [];
        var maxChunkLength = 16383;
        for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
          parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
        }
        if (extraBytes === 1) {
          tmp = uint8[len2 - 1];
          parts.push(
            lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
          );
        } else if (extraBytes === 2) {
          tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
          parts.push(
            lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
          );
        }
        return parts.join("");
      }
    }
  });

  // node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js
  var require_ieee754 = __commonJS({
    "node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js"(exports) {
      init_dist();
      exports.read = function(buffer, offset, isLE, mLen, nBytes) {
        var e, m;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i = isLE ? nBytes - 1 : 0;
        var d = isLE ? -1 : 1;
        var s2 = buffer[offset + i];
        i += d;
        e = s2 & (1 << -nBits) - 1;
        s2 >>= -nBits;
        nBits += eLen;
        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }
        m = e & (1 << -nBits) - 1;
        e >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }
        if (e === 0) {
          e = 1 - eBias;
        } else if (e === eMax) {
          return m ? NaN : (s2 ? -1 : 1) * Infinity;
        } else {
          m = m + Math.pow(2, mLen);
          e = e - eBias;
        }
        return (s2 ? -1 : 1) * m * Math.pow(2, e - mLen);
      };
      exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i = isLE ? 0 : nBytes - 1;
        var d = isLE ? 1 : -1;
        var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
        value = Math.abs(value);
        if (isNaN(value) || value === Infinity) {
          m = isNaN(value) ? 1 : 0;
          e = eMax;
        } else {
          e = Math.floor(Math.log(value) / Math.LN2);
          if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
          }
          if (e + eBias >= 1) {
            value += rt / c;
          } else {
            value += rt * Math.pow(2, 1 - eBias);
          }
          if (value * c >= 2) {
            e++;
            c /= 2;
          }
          if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
          } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
          } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
          }
        }
        for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
        }
        e = e << mLen | m;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
        }
        buffer[offset + i - d] |= s2 * 128;
      };
    }
  });

  // node_modules/.pnpm/buffer@6.0.3_patch_hash=zkkuxompt5d553skpnegwi5wuy/node_modules/buffer/index.js
  var require_buffer = __commonJS({
    "node_modules/.pnpm/buffer@6.0.3_patch_hash=zkkuxompt5d553skpnegwi5wuy/node_modules/buffer/index.js"(exports) {
      "use strict";
      init_dist();
      var base64 = require_base64_js();
      var ieee754 = require_ieee754();
      var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
      exports.Buffer = Buffer2;
      exports.SlowBuffer = SlowBuffer;
      exports.INSPECT_MAX_BYTES = 50;
      var K_MAX_LENGTH = 2147483647;
      exports.kMaxLength = K_MAX_LENGTH;
      var { Uint8Array: GlobalUint8Array, ArrayBuffer: GlobalArrayBuffer, SharedArrayBuffer: GlobalSharedArrayBuffer } = globalThis;
      Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
      if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
        console.error(
          "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
        );
      }
      function typedArraySupport() {
        try {
          const arr = new GlobalUint8Array(1);
          const proto = { foo: function() {
            return 42;
          } };
          Object.setPrototypeOf(proto, GlobalUint8Array.prototype);
          Object.setPrototypeOf(arr, proto);
          return arr.foo() === 42;
        } catch (e) {
          return false;
        }
      }
      Object.defineProperty(Buffer2.prototype, "parent", {
        enumerable: true,
        get: function() {
          if (!Buffer2.isBuffer(this))
            return void 0;
          return this.buffer;
        }
      });
      Object.defineProperty(Buffer2.prototype, "offset", {
        enumerable: true,
        get: function() {
          if (!Buffer2.isBuffer(this))
            return void 0;
          return this.byteOffset;
        }
      });
      function createBuffer(length) {
        if (length > K_MAX_LENGTH) {
          throw new RangeError('The value "' + length + '" is invalid for option "size"');
        }
        const buf = new GlobalUint8Array(length);
        Object.setPrototypeOf(buf, Buffer2.prototype);
        return buf;
      }
      function Buffer2(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          if (typeof encodingOrOffset === "string") {
            throw new TypeError(
              'The "string" argument must be of type string. Received type number'
            );
          }
          return allocUnsafe(arg);
        }
        return from(arg, encodingOrOffset, length);
      }
      Buffer2.poolSize = 8192;
      function from(value, encodingOrOffset, length) {
        if (typeof value === "string") {
          return fromString(value, encodingOrOffset);
        }
        if (GlobalArrayBuffer.isView(value)) {
          return fromArrayView(value);
        }
        if (value == null) {
          throw new TypeError(
            "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
          );
        }
        if (isInstance(value, GlobalArrayBuffer) || value && isInstance(value.buffer, GlobalArrayBuffer)) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof GlobalSharedArrayBuffer !== "undefined" && (isInstance(value, GlobalSharedArrayBuffer) || value && isInstance(value.buffer, GlobalSharedArrayBuffer))) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof value === "number") {
          throw new TypeError(
            'The "value" argument must not be of type number. Received type number'
          );
        }
        const valueOf = value.valueOf && value.valueOf();
        if (valueOf != null && valueOf !== value) {
          return Buffer2.from(valueOf, encodingOrOffset, length);
        }
        const b = fromObject(value);
        if (b)
          return b;
        if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
          return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
        }
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      Buffer2.from = function(value, encodingOrOffset, length) {
        return from(value, encodingOrOffset, length);
      };
      Object.setPrototypeOf(Buffer2.prototype, GlobalUint8Array.prototype);
      Object.setPrototypeOf(Buffer2, GlobalUint8Array);
      function assertSize(size) {
        if (typeof size !== "number") {
          throw new TypeError('"size" argument must be of type number');
        } else if (size < 0) {
          throw new RangeError('The value "' + size + '" is invalid for option "size"');
        }
      }
      function alloc(size, fill, encoding) {
        assertSize(size);
        if (size <= 0) {
          return createBuffer(size);
        }
        if (fill !== void 0) {
          return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
        }
        return createBuffer(size);
      }
      Buffer2.alloc = function(size, fill, encoding) {
        return alloc(size, fill, encoding);
      };
      function allocUnsafe(size) {
        assertSize(size);
        return createBuffer(size < 0 ? 0 : checked(size) | 0);
      }
      Buffer2.allocUnsafe = function(size) {
        return allocUnsafe(size);
      };
      Buffer2.allocUnsafeSlow = function(size) {
        return allocUnsafe(size);
      };
      function fromString(string, encoding) {
        if (typeof encoding !== "string" || encoding === "") {
          encoding = "utf8";
        }
        if (!Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        const length = byteLength(string, encoding) | 0;
        let buf = createBuffer(length);
        const actual = buf.write(string, encoding);
        if (actual !== length) {
          buf = buf.slice(0, actual);
        }
        return buf;
      }
      function fromArrayLike(array) {
        const length = array.length < 0 ? 0 : checked(array.length) | 0;
        const buf = createBuffer(length);
        for (let i = 0; i < length; i += 1) {
          buf[i] = array[i] & 255;
        }
        return buf;
      }
      function fromArrayView(arrayView) {
        if (isInstance(arrayView, GlobalUint8Array)) {
          const copy = new GlobalUint8Array(arrayView);
          return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
        }
        return fromArrayLike(arrayView);
      }
      function fromArrayBuffer(array, byteOffset, length) {
        if (byteOffset < 0 || array.byteLength < byteOffset) {
          throw new RangeError('"offset" is outside of buffer bounds');
        }
        if (array.byteLength < byteOffset + (length || 0)) {
          throw new RangeError('"length" is outside of buffer bounds');
        }
        let buf;
        if (byteOffset === void 0 && length === void 0) {
          buf = new GlobalUint8Array(array);
        } else if (length === void 0) {
          buf = new GlobalUint8Array(array, byteOffset);
        } else {
          buf = new GlobalUint8Array(array, byteOffset, length);
        }
        Object.setPrototypeOf(buf, Buffer2.prototype);
        return buf;
      }
      function fromObject(obj) {
        if (Buffer2.isBuffer(obj)) {
          const len = checked(obj.length) | 0;
          const buf = createBuffer(len);
          if (buf.length === 0) {
            return buf;
          }
          obj.copy(buf, 0, 0, len);
          return buf;
        }
        if (obj.length !== void 0) {
          if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
            return createBuffer(0);
          }
          return fromArrayLike(obj);
        }
        if (obj.type === "Buffer" && Array.isArray(obj.data)) {
          return fromArrayLike(obj.data);
        }
      }
      function checked(length) {
        if (length >= K_MAX_LENGTH) {
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
        }
        return length | 0;
      }
      function SlowBuffer(length) {
        if (+length != length) {
          length = 0;
        }
        return Buffer2.alloc(+length);
      }
      Buffer2.isBuffer = function isBuffer(b) {
        return b != null && b._isBuffer === true && b !== Buffer2.prototype;
      };
      Buffer2.compare = function compare(a, b) {
        if (isInstance(a, GlobalUint8Array))
          a = Buffer2.from(a, a.offset, a.byteLength);
        if (isInstance(b, GlobalUint8Array))
          b = Buffer2.from(b, b.offset, b.byteLength);
        if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
          throw new TypeError(
            'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
          );
        }
        if (a === b)
          return 0;
        let x = a.length;
        let y = b.length;
        for (let i = 0, len = Math.min(x, y); i < len; ++i) {
          if (a[i] !== b[i]) {
            x = a[i];
            y = b[i];
            break;
          }
        }
        if (x < y)
          return -1;
        if (y < x)
          return 1;
        return 0;
      };
      Buffer2.isEncoding = function isEncoding(encoding) {
        switch (String(encoding).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      };
      Buffer2.concat = function concat(list, length) {
        if (!Array.isArray(list)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        if (list.length === 0) {
          return Buffer2.alloc(0);
        }
        let i;
        if (length === void 0) {
          length = 0;
          for (i = 0; i < list.length; ++i) {
            length += list[i].length;
          }
        }
        const buffer = Buffer2.allocUnsafe(length);
        let pos = 0;
        for (i = 0; i < list.length; ++i) {
          let buf = list[i];
          if (isInstance(buf, GlobalUint8Array)) {
            if (pos + buf.length > buffer.length) {
              if (!Buffer2.isBuffer(buf))
                buf = Buffer2.from(buf);
              buf.copy(buffer, pos);
            } else {
              GlobalUint8Array.prototype.set.call(
                buffer,
                buf,
                pos
              );
            }
          } else if (!Buffer2.isBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          } else {
            buf.copy(buffer, pos);
          }
          pos += buf.length;
        }
        return buffer;
      };
      function byteLength(string, encoding) {
        if (Buffer2.isBuffer(string)) {
          return string.length;
        }
        if (GlobalArrayBuffer.isView(string) || isInstance(string, GlobalArrayBuffer)) {
          return string.byteLength;
        }
        if (typeof string !== "string") {
          throw new TypeError(
            'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
          );
        }
        const len = string.length;
        const mustMatch = arguments.length > 2 && arguments[2] === true;
        if (!mustMatch && len === 0)
          return 0;
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "ascii":
            case "latin1":
            case "binary":
              return len;
            case "utf8":
            case "utf-8":
              return utf8ToBytes(string).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return len * 2;
            case "hex":
              return len >>> 1;
            case "base64":
              return base64ToBytes(string).length;
            default:
              if (loweredCase) {
                return mustMatch ? -1 : utf8ToBytes(string).length;
              }
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer2.byteLength = byteLength;
      function slowToString(encoding, start, end) {
        let loweredCase = false;
        if (start === void 0 || start < 0) {
          start = 0;
        }
        if (start > this.length) {
          return "";
        }
        if (end === void 0 || end > this.length) {
          end = this.length;
        }
        if (end <= 0) {
          return "";
        }
        end >>>= 0;
        start >>>= 0;
        if (end <= start) {
          return "";
        }
        if (!encoding)
          encoding = "utf8";
        while (true) {
          switch (encoding) {
            case "hex":
              return hexSlice(this, start, end);
            case "utf8":
            case "utf-8":
              return utf8Slice(this, start, end);
            case "ascii":
              return asciiSlice(this, start, end);
            case "latin1":
            case "binary":
              return latin1Slice(this, start, end);
            case "base64":
              return base64Slice(this, start, end);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return utf16leSlice(this, start, end);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = (encoding + "").toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer2.prototype._isBuffer = true;
      function swap(b, n, m) {
        const i = b[n];
        b[n] = b[m];
        b[m] = i;
      }
      Buffer2.prototype.swap16 = function swap16() {
        const len = this.length;
        if (len % 2 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        }
        for (let i = 0; i < len; i += 2) {
          swap(this, i, i + 1);
        }
        return this;
      };
      Buffer2.prototype.swap32 = function swap32() {
        const len = this.length;
        if (len % 4 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        }
        for (let i = 0; i < len; i += 4) {
          swap(this, i, i + 3);
          swap(this, i + 1, i + 2);
        }
        return this;
      };
      Buffer2.prototype.swap64 = function swap64() {
        const len = this.length;
        if (len % 8 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        }
        for (let i = 0; i < len; i += 8) {
          swap(this, i, i + 7);
          swap(this, i + 1, i + 6);
          swap(this, i + 2, i + 5);
          swap(this, i + 3, i + 4);
        }
        return this;
      };
      Buffer2.prototype.toString = function toString() {
        const length = this.length;
        if (length === 0)
          return "";
        if (arguments.length === 0)
          return utf8Slice(this, 0, length);
        return slowToString.apply(this, arguments);
      };
      Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
      Buffer2.prototype.equals = function equals(b) {
        if (!Buffer2.isBuffer(b))
          throw new TypeError("Argument must be a Buffer");
        if (this === b)
          return true;
        return Buffer2.compare(this, b) === 0;
      };
      Buffer2.prototype.inspect = function inspect() {
        let str = "";
        const max = exports.INSPECT_MAX_BYTES;
        str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
        if (this.length > max)
          str += " ... ";
        return "<Buffer " + str + ">";
      };
      if (customInspectSymbol) {
        Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
      }
      Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
        if (isInstance(target, GlobalUint8Array)) {
          target = Buffer2.from(target, target.offset, target.byteLength);
        }
        if (!Buffer2.isBuffer(target)) {
          throw new TypeError(
            'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
          );
        }
        if (start === void 0) {
          start = 0;
        }
        if (end === void 0) {
          end = target ? target.length : 0;
        }
        if (thisStart === void 0) {
          thisStart = 0;
        }
        if (thisEnd === void 0) {
          thisEnd = this.length;
        }
        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
          throw new RangeError("out of range index");
        }
        if (thisStart >= thisEnd && start >= end) {
          return 0;
        }
        if (thisStart >= thisEnd) {
          return -1;
        }
        if (start >= end) {
          return 1;
        }
        start >>>= 0;
        end >>>= 0;
        thisStart >>>= 0;
        thisEnd >>>= 0;
        if (this === target)
          return 0;
        let x = thisEnd - thisStart;
        let y = end - start;
        const len = Math.min(x, y);
        const thisCopy = this.slice(thisStart, thisEnd);
        const targetCopy = target.slice(start, end);
        for (let i = 0; i < len; ++i) {
          if (thisCopy[i] !== targetCopy[i]) {
            x = thisCopy[i];
            y = targetCopy[i];
            break;
          }
        }
        if (x < y)
          return -1;
        if (y < x)
          return 1;
        return 0;
      };
      function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
        if (buffer.length === 0)
          return -1;
        if (typeof byteOffset === "string") {
          encoding = byteOffset;
          byteOffset = 0;
        } else if (byteOffset > 2147483647) {
          byteOffset = 2147483647;
        } else if (byteOffset < -2147483648) {
          byteOffset = -2147483648;
        }
        byteOffset = +byteOffset;
        if (numberIsNaN(byteOffset)) {
          byteOffset = dir ? 0 : buffer.length - 1;
        }
        if (byteOffset < 0)
          byteOffset = buffer.length + byteOffset;
        if (byteOffset >= buffer.length) {
          if (dir)
            return -1;
          else
            byteOffset = buffer.length - 1;
        } else if (byteOffset < 0) {
          if (dir)
            byteOffset = 0;
          else
            return -1;
        }
        if (typeof val === "string") {
          val = Buffer2.from(val, encoding);
        }
        if (Buffer2.isBuffer(val)) {
          if (val.length === 0) {
            return -1;
          }
          return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
        } else if (typeof val === "number") {
          val = val & 255;
          if (typeof GlobalUint8Array.prototype.indexOf === "function") {
            if (dir) {
              return GlobalUint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            } else {
              return GlobalUint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
            }
          }
          return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
        }
        throw new TypeError("val must be string, number or Buffer");
      }
      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
        let indexSize = 1;
        let arrLength = arr.length;
        let valLength = val.length;
        if (encoding !== void 0) {
          encoding = String(encoding).toLowerCase();
          if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) {
              return -1;
            }
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
          }
        }
        function read(buf, i2) {
          if (indexSize === 1) {
            return buf[i2];
          } else {
            return buf.readUInt16BE(i2 * indexSize);
          }
        }
        let i;
        if (dir) {
          let foundIndex = -1;
          for (i = byteOffset; i < arrLength; i++) {
            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
              if (foundIndex === -1)
                foundIndex = i;
              if (i - foundIndex + 1 === valLength)
                return foundIndex * indexSize;
            } else {
              if (foundIndex !== -1)
                i -= i - foundIndex;
              foundIndex = -1;
            }
          }
        } else {
          if (byteOffset + valLength > arrLength)
            byteOffset = arrLength - valLength;
          for (i = byteOffset; i >= 0; i--) {
            let found = true;
            for (let j = 0; j < valLength; j++) {
              if (read(arr, i + j) !== read(val, j)) {
                found = false;
                break;
              }
            }
            if (found)
              return i;
          }
        }
        return -1;
      }
      Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
        return this.indexOf(val, byteOffset, encoding) !== -1;
      };
      Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
      };
      Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
      };
      function hexWrite(buf, string, offset, length) {
        offset = Number(offset) || 0;
        const remaining = buf.length - offset;
        if (!length) {
          length = remaining;
        } else {
          length = Number(length);
          if (length > remaining) {
            length = remaining;
          }
        }
        const strLen = string.length;
        if (length > strLen / 2) {
          length = strLen / 2;
        }
        let i;
        for (i = 0; i < length; ++i) {
          const parsed = parseInt(string.substr(i * 2, 2), 16);
          if (numberIsNaN(parsed))
            return i;
          buf[offset + i] = parsed;
        }
        return i;
      }
      function utf8Write(buf, string, offset, length) {
        return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
      }
      function asciiWrite(buf, string, offset, length) {
        return blitBuffer(asciiToBytes(string), buf, offset, length);
      }
      function base64Write(buf, string, offset, length) {
        return blitBuffer(base64ToBytes(string), buf, offset, length);
      }
      function ucs2Write(buf, string, offset, length) {
        return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
      }
      Buffer2.prototype.write = function write(string, offset, length, encoding) {
        if (offset === void 0) {
          encoding = "utf8";
          length = this.length;
          offset = 0;
        } else if (length === void 0 && typeof offset === "string") {
          encoding = offset;
          length = this.length;
          offset = 0;
        } else if (isFinite(offset)) {
          offset = offset >>> 0;
          if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === void 0)
              encoding = "utf8";
          } else {
            encoding = length;
            length = void 0;
          }
        } else {
          throw new Error(
            "Buffer.write(string, encoding, offset[, length]) is no longer supported"
          );
        }
        const remaining = this.length - offset;
        if (length === void 0 || length > remaining)
          length = remaining;
        if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
          throw new RangeError("Attempt to write outside buffer bounds");
        }
        if (!encoding)
          encoding = "utf8";
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "hex":
              return hexWrite(this, string, offset, length);
            case "utf8":
            case "utf-8":
              return utf8Write(this, string, offset, length);
            case "ascii":
            case "latin1":
            case "binary":
              return asciiWrite(this, string, offset, length);
            case "base64":
              return base64Write(this, string, offset, length);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return ucs2Write(this, string, offset, length);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      };
      Buffer2.prototype.toJSON = function toJSON() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      function base64Slice(buf, start, end) {
        if (start === 0 && end === buf.length) {
          return base64.fromByteArray(buf);
        } else {
          return base64.fromByteArray(buf.slice(start, end));
        }
      }
      function utf8Slice(buf, start, end) {
        end = Math.min(buf.length, end);
        const res = [];
        let i = start;
        while (i < end) {
          const firstByte = buf[i];
          let codePoint = null;
          let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
          if (i + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch (bytesPerSequence) {
              case 1:
                if (firstByte < 128) {
                  codePoint = firstByte;
                }
                break;
              case 2:
                secondByte = buf[i + 1];
                if ((secondByte & 192) === 128) {
                  tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                  if (tempCodePoint > 127) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 3:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                  if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 4:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                fourthByte = buf[i + 3];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                  if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                    codePoint = tempCodePoint;
                  }
                }
            }
          }
          if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
          } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
          }
          res.push(codePoint);
          i += bytesPerSequence;
        }
        return decodeCodePointsArray(res);
      }
      var MAX_ARGUMENTS_LENGTH = 4096;
      function decodeCodePointsArray(codePoints) {
        const len = codePoints.length;
        if (len <= MAX_ARGUMENTS_LENGTH) {
          return String.fromCharCode.apply(String, codePoints);
        }
        let res = "";
        let i = 0;
        while (i < len) {
          res += String.fromCharCode.apply(
            String,
            codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
          );
        }
        return res;
      }
      function asciiSlice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i] & 127);
        }
        return ret;
      }
      function latin1Slice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i]);
        }
        return ret;
      }
      function hexSlice(buf, start, end) {
        const len = buf.length;
        if (!start || start < 0)
          start = 0;
        if (!end || end < 0 || end > len)
          end = len;
        let out = "";
        for (let i = start; i < end; ++i) {
          out += hexSliceLookupTable[buf[i]];
        }
        return out;
      }
      function utf16leSlice(buf, start, end) {
        const bytes = buf.slice(start, end);
        let res = "";
        for (let i = 0; i < bytes.length - 1; i += 2) {
          res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
        }
        return res;
      }
      Buffer2.prototype.slice = function slice(start, end) {
        const len = this.length;
        start = ~~start;
        end = end === void 0 ? len : ~~end;
        if (start < 0) {
          start += len;
          if (start < 0)
            start = 0;
        } else if (start > len) {
          start = len;
        }
        if (end < 0) {
          end += len;
          if (end < 0)
            end = 0;
        } else if (end > len) {
          end = len;
        }
        if (end < start)
          end = start;
        const newBuf = this.subarray(start, end);
        Object.setPrototypeOf(newBuf, Buffer2.prototype);
        return newBuf;
      };
      function checkOffset(offset, ext, length) {
        if (offset % 1 !== 0 || offset < 0)
          throw new RangeError("offset is not uint");
        if (offset + ext > length)
          throw new RangeError("Trying to access beyond buffer length");
      }
      Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        let val = this[offset];
        let mul = 1;
        let i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        return val;
      };
      Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          checkOffset(offset, byteLength2, this.length);
        }
        let val = this[offset + --byteLength2];
        let mul = 1;
        while (byteLength2 > 0 && (mul *= 256)) {
          val += this[offset + --byteLength2] * mul;
        }
        return val;
      };
      Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        return this[offset];
      };
      Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] | this[offset + 1] << 8;
      };
      Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] << 8 | this[offset + 1];
      };
      Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
      };
      Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
      };
      Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
        const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
        return BigInt(lo) + (BigInt(hi) << BigInt(32));
      });
      Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
        const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
        return (BigInt(hi) << BigInt(32)) + BigInt(lo);
      });
      Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        let val = this[offset];
        let mul = 1;
        let i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        let i = byteLength2;
        let mul = 1;
        let val = this[offset + --i];
        while (i > 0 && (mul *= 256)) {
          val += this[offset + --i] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        if (!(this[offset] & 128))
          return this[offset];
        return (255 - this[offset] + 1) * -1;
      };
      Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        const val = this[offset] | this[offset + 1] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        const val = this[offset + 1] | this[offset] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
      };
      Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
      };
      Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
        return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
      });
      Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val = (first << 24) + // Overflow
        this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
        return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
      });
      Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, true, 23, 4);
      };
      Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, false, 23, 4);
      };
      Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, true, 52, 8);
      };
      Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, false, 52, 8);
      };
      function checkInt(buf, value, offset, ext, max, min) {
        if (!Buffer2.isBuffer(buf))
          throw new TypeError('"buffer" argument must be a Buffer instance');
        if (value > max || value < min)
          throw new RangeError('"value" argument is out of bounds');
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
      }
      Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        let mul = 1;
        let i = 0;
        this[offset] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        let i = byteLength2 - 1;
        let mul = 1;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 255, 0);
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 255;
        return offset + 4;
      };
      Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      function wrtBigUInt64LE(buf, value, offset, min, max) {
        checkIntBI(value, min, max, buf, offset, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        return offset;
      }
      function wrtBigUInt64BE(buf, value, offset, min, max) {
        checkIntBI(value, min, max, buf, offset, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset + 7] = lo;
        lo = lo >> 8;
        buf[offset + 6] = lo;
        lo = lo >> 8;
        buf[offset + 5] = lo;
        lo = lo >> 8;
        buf[offset + 4] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset + 3] = hi;
        hi = hi >> 8;
        buf[offset + 2] = hi;
        hi = hi >> 8;
        buf[offset + 1] = hi;
        hi = hi >> 8;
        buf[offset] = hi;
        return offset + 8;
      }
      Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        let i = 0;
        let mul = 1;
        let sub = 0;
        this[offset] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        let i = byteLength2 - 1;
        let mul = 1;
        let sub = 0;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 127, -128);
        if (value < 0)
          value = 255 + value + 1;
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
        return offset + 4;
      };
      Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        if (value < 0)
          value = 4294967295 + value + 1;
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      function checkIEEE754(buf, value, offset, ext, max, min) {
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
        if (offset < 0)
          throw new RangeError("Index out of range");
      }
      function writeFloat(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
        }
        ieee754.write(buf, value, offset, littleEndian, 23, 4);
        return offset + 4;
      }
      Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
        return writeFloat(this, value, offset, true, noAssert);
      };
      Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
        return writeFloat(this, value, offset, false, noAssert);
      };
      function writeDouble(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
        }
        ieee754.write(buf, value, offset, littleEndian, 52, 8);
        return offset + 8;
      }
      Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
        return writeDouble(this, value, offset, true, noAssert);
      };
      Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
        return writeDouble(this, value, offset, false, noAssert);
      };
      Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
        if (!Buffer2.isBuffer(target))
          throw new TypeError("argument should be a Buffer");
        if (!start)
          start = 0;
        if (!end && end !== 0)
          end = this.length;
        if (targetStart >= target.length)
          targetStart = target.length;
        if (!targetStart)
          targetStart = 0;
        if (end > 0 && end < start)
          end = start;
        if (end === start)
          return 0;
        if (target.length === 0 || this.length === 0)
          return 0;
        if (targetStart < 0) {
          throw new RangeError("targetStart out of bounds");
        }
        if (start < 0 || start >= this.length)
          throw new RangeError("Index out of range");
        if (end < 0)
          throw new RangeError("sourceEnd out of bounds");
        if (end > this.length)
          end = this.length;
        if (target.length - targetStart < end - start) {
          end = target.length - targetStart + start;
        }
        const len = end - start;
        if (this === target && typeof GlobalUint8Array.prototype.copyWithin === "function") {
          this.copyWithin(targetStart, start, end);
        } else {
          GlobalUint8Array.prototype.set.call(
            target,
            this.subarray(start, end),
            targetStart
          );
        }
        return len;
      };
      Buffer2.prototype.fill = function fill(val, start, end, encoding) {
        if (typeof val === "string") {
          if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
          } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
          }
          if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
          }
          if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
          }
          if (val.length === 1) {
            const code = val.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") {
              val = code;
            }
          }
        } else if (typeof val === "number") {
          val = val & 255;
        } else if (typeof val === "boolean") {
          val = Number(val);
        }
        if (start < 0 || this.length < start || this.length < end) {
          throw new RangeError("Out of range index");
        }
        if (end <= start) {
          return this;
        }
        start = start >>> 0;
        end = end === void 0 ? this.length : end >>> 0;
        if (!val)
          val = 0;
        let i;
        if (typeof val === "number") {
          for (i = start; i < end; ++i) {
            this[i] = val;
          }
        } else {
          const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
          const len = bytes.length;
          if (len === 0) {
            throw new TypeError('The value "' + val + '" is invalid for argument "value"');
          }
          for (i = 0; i < end - start; ++i) {
            this[i + start] = bytes[i % len];
          }
        }
        return this;
      };
      var errors = {};
      function E(sym, getMessage, Base) {
        errors[sym] = class NodeError extends Base {
          constructor() {
            super();
            Object.defineProperty(this, "message", {
              value: getMessage.apply(this, arguments),
              writable: true,
              configurable: true
            });
            this.name = `${this.name} [${sym}]`;
            this.stack;
            delete this.name;
          }
          get code() {
            return sym;
          }
          set code(value) {
            Object.defineProperty(this, "code", {
              configurable: true,
              enumerable: true,
              value,
              writable: true
            });
          }
          toString() {
            return `${this.name} [${sym}]: ${this.message}`;
          }
        };
      }
      E(
        "ERR_BUFFER_OUT_OF_BOUNDS",
        function(name) {
          if (name) {
            return `${name} is outside of buffer bounds`;
          }
          return "Attempt to access memory outside buffer bounds";
        },
        RangeError
      );
      E(
        "ERR_INVALID_ARG_TYPE",
        function(name, actual) {
          return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
        },
        TypeError
      );
      E(
        "ERR_OUT_OF_RANGE",
        function(str, range, input) {
          let msg = `The value of "${str}" is out of range.`;
          let received = input;
          if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
            received = addNumericalSeparator(String(input));
          } else if (typeof input === "bigint") {
            received = String(input);
            if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
              received = addNumericalSeparator(received);
            }
            received += "n";
          }
          msg += ` It must be ${range}. Received ${received}`;
          return msg;
        },
        RangeError
      );
      function addNumericalSeparator(val) {
        let res = "";
        let i = val.length;
        const start = val[0] === "-" ? 1 : 0;
        for (; i >= start + 4; i -= 3) {
          res = `_${val.slice(i - 3, i)}${res}`;
        }
        return `${val.slice(0, i)}${res}`;
      }
      function checkBounds(buf, offset, byteLength2) {
        validateNumber(offset, "offset");
        if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
          boundsError(offset, buf.length - (byteLength2 + 1));
        }
      }
      function checkIntBI(value, min, max, buf, offset, byteLength2) {
        if (value > max || value < min) {
          const n = typeof min === "bigint" ? "n" : "";
          let range;
          if (byteLength2 > 3) {
            if (min === 0 || min === BigInt(0)) {
              range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
            } else {
              range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
            }
          } else {
            range = `>= ${min}${n} and <= ${max}${n}`;
          }
          throw new errors.ERR_OUT_OF_RANGE("value", range, value);
        }
        checkBounds(buf, offset, byteLength2);
      }
      function validateNumber(value, name) {
        if (typeof value !== "number") {
          throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
        }
      }
      function boundsError(value, length, type) {
        if (Math.floor(value) !== value) {
          validateNumber(value, type);
          throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
        }
        if (length < 0) {
          throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
        }
        throw new errors.ERR_OUT_OF_RANGE(
          type || "offset",
          `>= ${type ? 1 : 0} and <= ${length}`,
          value
        );
      }
      var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
      function base64clean(str) {
        str = str.split("=")[0];
        str = str.trim().replace(INVALID_BASE64_RE, "");
        if (str.length < 2)
          return "";
        while (str.length % 4 !== 0) {
          str = str + "=";
        }
        return str;
      }
      function utf8ToBytes(string, units) {
        units = units || Infinity;
        let codePoint;
        const length = string.length;
        let leadSurrogate = null;
        const bytes = [];
        for (let i = 0; i < length; ++i) {
          codePoint = string.charCodeAt(i);
          if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
              if (codePoint > 56319) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              } else if (i + 1 === length) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              }
              leadSurrogate = codePoint;
              continue;
            }
            if (codePoint < 56320) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              leadSurrogate = codePoint;
              continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
          } else if (leadSurrogate) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
          }
          leadSurrogate = null;
          if (codePoint < 128) {
            if ((units -= 1) < 0)
              break;
            bytes.push(codePoint);
          } else if (codePoint < 2048) {
            if ((units -= 2) < 0)
              break;
            bytes.push(
              codePoint >> 6 | 192,
              codePoint & 63 | 128
            );
          } else if (codePoint < 65536) {
            if ((units -= 3) < 0)
              break;
            bytes.push(
              codePoint >> 12 | 224,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else if (codePoint < 1114112) {
            if ((units -= 4) < 0)
              break;
            bytes.push(
              codePoint >> 18 | 240,
              codePoint >> 12 & 63 | 128,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else {
            throw new Error("Invalid code point");
          }
        }
        return bytes;
      }
      function asciiToBytes(str) {
        const byteArray = [];
        for (let i = 0; i < str.length; ++i) {
          byteArray.push(str.charCodeAt(i) & 255);
        }
        return byteArray;
      }
      function utf16leToBytes(str, units) {
        let c, hi, lo;
        const byteArray = [];
        for (let i = 0; i < str.length; ++i) {
          if ((units -= 2) < 0)
            break;
          c = str.charCodeAt(i);
          hi = c >> 8;
          lo = c % 256;
          byteArray.push(lo);
          byteArray.push(hi);
        }
        return byteArray;
      }
      function base64ToBytes(str) {
        return base64.toByteArray(base64clean(str));
      }
      function blitBuffer(src, dst, offset, length) {
        let i;
        for (i = 0; i < length; ++i) {
          if (i + offset >= dst.length || i >= src.length)
            break;
          dst[i + offset] = src[i];
        }
        return i;
      }
      function isInstance(obj, type) {
        return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
      }
      function numberIsNaN(obj) {
        return obj !== obj;
      }
      var hexSliceLookupTable = function() {
        const alphabet = "0123456789abcdef";
        const table = new Array(256);
        for (let i = 0; i < 16; ++i) {
          const i16 = i * 16;
          for (let j = 0; j < 16; ++j) {
            table[i16 + j] = alphabet[i] + alphabet[j];
          }
        }
        return table;
      }();
      function defineBigIntMethod(fn) {
        return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
      }
      function BufferBigIntNotDefined() {
        throw new Error("BigInt not supported");
      }
    }
  });

  // node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js
  var require_browser = __commonJS({
    "node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js"(exports, module) {
      init_dist();
      var process = module.exports = {};
      var cachedSetTimeout;
      var cachedClearTimeout;
      function defaultSetTimout() {
        throw new Error("setTimeout has not been defined");
      }
      function defaultClearTimeout() {
        throw new Error("clearTimeout has not been defined");
      }
      (function() {
        try {
          if (typeof setTimeout === "function") {
            cachedSetTimeout = setTimeout;
          } else {
            cachedSetTimeout = defaultSetTimout;
          }
        } catch (e) {
          cachedSetTimeout = defaultSetTimout;
        }
        try {
          if (typeof clearTimeout === "function") {
            cachedClearTimeout = clearTimeout;
          } else {
            cachedClearTimeout = defaultClearTimeout;
          }
        } catch (e) {
          cachedClearTimeout = defaultClearTimeout;
        }
      })();
      function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
          return setTimeout(fun, 0);
        }
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
          cachedSetTimeout = setTimeout;
          return setTimeout(fun, 0);
        }
        try {
          return cachedSetTimeout(fun, 0);
        } catch (e) {
          try {
            return cachedSetTimeout.call(null, fun, 0);
          } catch (e2) {
            return cachedSetTimeout.call(this, fun, 0);
          }
        }
      }
      function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
          return clearTimeout(marker);
        }
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
          cachedClearTimeout = clearTimeout;
          return clearTimeout(marker);
        }
        try {
          return cachedClearTimeout(marker);
        } catch (e) {
          try {
            return cachedClearTimeout.call(null, marker);
          } catch (e2) {
            return cachedClearTimeout.call(this, marker);
          }
        }
      }
      var queue = [];
      var draining = false;
      var currentQueue;
      var queueIndex = -1;
      function cleanUpNextTick() {
        if (!draining || !currentQueue) {
          return;
        }
        draining = false;
        if (currentQueue.length) {
          queue = currentQueue.concat(queue);
        } else {
          queueIndex = -1;
        }
        if (queue.length) {
          drainQueue();
        }
      }
      function drainQueue() {
        if (draining) {
          return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;
        var len = queue.length;
        while (len) {
          currentQueue = queue;
          queue = [];
          while (++queueIndex < len) {
            if (currentQueue) {
              currentQueue[queueIndex].run();
            }
          }
          queueIndex = -1;
          len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
      }
      process.nextTick = function(fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
          for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
          }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
          runTimeout(drainQueue);
        }
      };
      function Item(fun, array) {
        this.fun = fun;
        this.array = array;
      }
      Item.prototype.run = function() {
        this.fun.apply(null, this.array);
      };
      process.title = "browser";
      process.browser = true;
      process.env = {};
      process.argv = [];
      process.version = "";
      process.versions = {};
      function noop() {
      }
      process.on = noop;
      process.addListener = noop;
      process.once = noop;
      process.off = noop;
      process.removeListener = noop;
      process.removeAllListeners = noop;
      process.emit = noop;
      process.prependListener = noop;
      process.prependOnceListener = noop;
      process.listeners = function(name) {
        return [];
      };
      process.binding = function(name) {
        throw new Error("process.binding is not supported");
      };
      process.cwd = function() {
        return "/";
      };
      process.chdir = function(dir) {
        throw new Error("process.chdir is not supported");
      };
      process.umask = function() {
        return 0;
      };
    }
  });

  // shims/dist/index.js
  var import_buffer_polyfill, import_process, o;
  var init_dist = __esm({
    "shims/dist/index.js"() {
      "use strict";
      import_buffer_polyfill = __toESM(require_buffer(), 1);
      import_process = __toESM(require_browser(), 1);
      o = globalThis || void 0 || self;
    }
  });

  // shims/banner/index.cjs
  var require_banner = __commonJS({
    "shims/banner/index.cjs"() {
      init_dist();
      globalThis.Buffer = globalThis.Buffer || import_buffer_polyfill.Buffer;
      globalThis.global = globalThis.global || o;
      globalThis.process = globalThis.process || import_process.default;
    }
  });
  require_banner();
})();
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
*/

import {
  require_jsx_runtime
} from "./chunk-UGZBWPPI.js";
import {
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  blake2AsU8a,
  decodeAddress,
  detectPackage,
  encodeAddress,
  esm_default,
  ethereumEncode,
  hasProcess,
  import_index,
  isHex,
  isU8a,
  isUndefined,
  objectSpread,
  stringToU8a,
  u8aToHex
} from "./chunk-SQTQRON3.js";
import {
  require_react
} from "./chunk-TYQ3GMO7.js";
import {
  __commonJS,
  __toESM,
  require_dist
} from "./chunk-CMUF5OCO.js";

// node_modules/ethereum-blockies-base64/dist/main.js
var require_main = __commonJS({
  "node_modules/ethereum-blockies-base64/dist/main.js"(exports2, module2) {
    var import_dist56 = __toESM(require_dist());
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports2 === "object" && typeof module2 === "object")
        module2.exports = factory();
      else if (typeof define === "function" && define.amd)
        define([], factory);
      else if (typeof exports2 === "object")
        exports2["ethereum-blockies-base64"] = factory();
      else
        root["ethereum-blockies-base64"] = factory();
    })(exports2, function() {
      return (
        /******/
        function(modules) {
          var installedModules = {};
          function __webpack_require__(moduleId) {
            if (installedModules[moduleId])
              return installedModules[moduleId].exports;
            var module3 = installedModules[moduleId] = {
              /******/
              exports: {},
              /******/
              id: moduleId,
              /******/
              loaded: false
              /******/
            };
            modules[moduleId].call(module3.exports, module3, module3.exports, __webpack_require__);
            module3.loaded = true;
            return module3.exports;
          }
          __webpack_require__.m = modules;
          __webpack_require__.c = installedModules;
          __webpack_require__.p = "";
          return __webpack_require__(0);
        }([
          /* 0 */
          /***/
          function(module3, exports3, __webpack_require__) {
            const pnglib = __webpack_require__(1);
            const hsl2rgb = __webpack_require__(2);
            const randseed = new Array(4);
            function seedrand(seed) {
              for (let i3 = 0; i3 < randseed.length; i3++) {
                randseed[i3] = 0;
              }
              for (let i3 = 0; i3 < seed.length; i3++) {
                randseed[i3 % 4] = (randseed[i3 % 4] << 5) - randseed[i3 % 4] + seed.charCodeAt(i3);
              }
            }
            function rand() {
              const t3 = randseed[0] ^ randseed[0] << 11;
              randseed[0] = randseed[1];
              randseed[1] = randseed[2];
              randseed[2] = randseed[3];
              randseed[3] = randseed[3] ^ randseed[3] >> 19 ^ t3 ^ t3 >> 8;
              return (randseed[3] >>> 0) / (1 << 31 >>> 0);
            }
            function createColor() {
              const h2 = Math.floor(rand() * 360);
              const s3 = rand() * 60 + 40;
              const l3 = (rand() + rand() + rand() + rand()) * 25;
              return [h2 / 360, s3 / 100, l3 / 100];
            }
            function createImageData(size) {
              const width = size;
              const height = size;
              const dataWidth = Math.ceil(width / 2);
              const mirrorWidth = width - dataWidth;
              const data = [];
              for (let y3 = 0; y3 < height; y3++) {
                let row = [];
                for (let x3 = 0; x3 < dataWidth; x3++) {
                  row[x3] = Math.floor(rand() * 2.3);
                }
                const r3 = row.slice(0, mirrorWidth).reverse();
                row = row.concat(r3);
                for (let i3 = 0; i3 < row.length; i3++) {
                  data.push(row[i3]);
                }
              }
              return data;
            }
            function fillRect(png, x3, y3, w3, h2, color) {
              for (let i3 = 0; i3 < w3; i3++) {
                for (let j4 = 0; j4 < h2; j4++) {
                  png.buffer[png.index(x3 + i3, y3 + j4)] = color;
                }
              }
            }
            function buildOpts(opts) {
              if (!opts.seed) {
                throw new Error("No seed provided");
              }
              seedrand(opts.seed);
              return Object.assign({
                size: 8,
                scale: 16,
                color: createColor(),
                bgcolor: createColor(),
                spotcolor: createColor()
              }, opts);
            }
            function makeBlockie2(address) {
              const opts = buildOpts({ seed: address.toLowerCase() });
              const imageData = createImageData(opts.size);
              const width = Math.sqrt(imageData.length);
              const p2 = new pnglib(opts.size * opts.scale, opts.size * opts.scale, 3);
              const bgcolor = p2.color(...hsl2rgb(...opts.bgcolor));
              const color = p2.color(...hsl2rgb(...opts.color));
              const spotcolor = p2.color(...hsl2rgb(...opts.spotcolor));
              for (let i3 = 0; i3 < imageData.length; i3++) {
                const row = Math.floor(i3 / width);
                const col = i3 % width;
                if (imageData[i3]) {
                  const pngColor = imageData[i3] == 1 ? color : spotcolor;
                  fillRect(p2, col * opts.scale, row * opts.scale, opts.scale, opts.scale, pngColor);
                }
              }
              return `data:image/png;base64,${p2.getBase64()}`;
            }
            module3.exports = makeBlockie2;
          },
          /* 1 */
          /***/
          function(module3, exports3) {
            module3.exports = function(width, height, depth) {
              function write(buffer, offs) {
                for (var i4 = 2; i4 < arguments.length; i4++) {
                  for (var j5 = 0; j5 < arguments[i4].length; j5++) {
                    buffer[offs++] = arguments[i4].charAt(j5);
                  }
                }
              }
              function byte2(w3) {
                return String.fromCharCode(w3 >> 8 & 255, w3 & 255);
              }
              function byte4(w3) {
                return String.fromCharCode(w3 >> 24 & 255, w3 >> 16 & 255, w3 >> 8 & 255, w3 & 255);
              }
              function byte2lsb(w3) {
                return String.fromCharCode(w3 & 255, w3 >> 8 & 255);
              }
              this.width = width;
              this.height = height;
              this.depth = depth;
              this.pix_size = height * (width + 1);
              this.data_size = 2 + this.pix_size + 5 * Math.floor((65534 + this.pix_size) / 65535) + 4;
              this.ihdr_offs = 0;
              this.ihdr_size = 4 + 4 + 13 + 4;
              this.plte_offs = this.ihdr_offs + this.ihdr_size;
              this.plte_size = 4 + 4 + 3 * depth + 4;
              this.trns_offs = this.plte_offs + this.plte_size;
              this.trns_size = 4 + 4 + depth + 4;
              this.idat_offs = this.trns_offs + this.trns_size;
              this.idat_size = 4 + 4 + this.data_size + 4;
              this.iend_offs = this.idat_offs + this.idat_size;
              this.iend_size = 4 + 4 + 4;
              this.buffer_size = this.iend_offs + this.iend_size;
              this.buffer = new Array();
              this.palette = new Object();
              this.pindex = 0;
              var _crc32 = new Array();
              for (var i3 = 0; i3 < this.buffer_size; i3++) {
                this.buffer[i3] = "\0";
              }
              write(this.buffer, this.ihdr_offs, byte4(this.ihdr_size - 12), "IHDR", byte4(width), byte4(height), "\b");
              write(this.buffer, this.plte_offs, byte4(this.plte_size - 12), "PLTE");
              write(this.buffer, this.trns_offs, byte4(this.trns_size - 12), "tRNS");
              write(this.buffer, this.idat_offs, byte4(this.idat_size - 12), "IDAT");
              write(this.buffer, this.iend_offs, byte4(this.iend_size - 12), "IEND");
              var header = 8 + (7 << 4) << 8 | 3 << 6;
              header += 31 - header % 31;
              write(this.buffer, this.idat_offs + 8, byte2(header));
              for (var i3 = 0; (i3 << 16) - 1 < this.pix_size; i3++) {
                var size, bits;
                if (i3 + 65535 < this.pix_size) {
                  size = 65535;
                  bits = "\0";
                } else {
                  size = this.pix_size - (i3 << 16) - i3;
                  bits = "";
                }
                write(this.buffer, this.idat_offs + 8 + 2 + (i3 << 16) + (i3 << 2), bits, byte2lsb(size), byte2lsb(~size));
              }
              for (var i3 = 0; i3 < 256; i3++) {
                var c3 = i3;
                for (var j4 = 0; j4 < 8; j4++) {
                  if (c3 & 1) {
                    c3 = -306674912 ^ c3 >> 1 & 2147483647;
                  } else {
                    c3 = c3 >> 1 & 2147483647;
                  }
                }
                _crc32[i3] = c3;
              }
              this.index = function(x3, y3) {
                var i4 = y3 * (this.width + 1) + x3 + 1;
                var j5 = this.idat_offs + 8 + 2 + 5 * Math.floor(i4 / 65535 + 1) + i4;
                return j5;
              };
              this.color = function(red, green, blue, alpha) {
                alpha = alpha >= 0 ? alpha : 255;
                var color = ((alpha << 8 | red) << 8 | green) << 8 | blue;
                if (typeof this.palette[color] == "undefined") {
                  if (this.pindex == this.depth)
                    return "\0";
                  var ndx = this.plte_offs + 8 + 3 * this.pindex;
                  this.buffer[ndx + 0] = String.fromCharCode(red);
                  this.buffer[ndx + 1] = String.fromCharCode(green);
                  this.buffer[ndx + 2] = String.fromCharCode(blue);
                  this.buffer[this.trns_offs + 8 + this.pindex] = String.fromCharCode(alpha);
                  this.palette[color] = String.fromCharCode(this.pindex++);
                }
                return this.palette[color];
              };
              this.getBase64 = function() {
                var s3 = this.getDump();
                var ch = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
                var c1, c22, c32, e1, e22, e3, e4;
                var l3 = s3.length;
                var i4 = 0;
                var r3 = "";
                do {
                  c1 = s3.charCodeAt(i4);
                  e1 = c1 >> 2;
                  c22 = s3.charCodeAt(i4 + 1);
                  e22 = (c1 & 3) << 4 | c22 >> 4;
                  c32 = s3.charCodeAt(i4 + 2);
                  if (l3 < i4 + 2) {
                    e3 = 64;
                  } else {
                    e3 = (c22 & 15) << 2 | c32 >> 6;
                  }
                  if (l3 < i4 + 3) {
                    e4 = 64;
                  } else {
                    e4 = c32 & 63;
                  }
                  r3 += ch.charAt(e1) + ch.charAt(e22) + ch.charAt(e3) + ch.charAt(e4);
                } while ((i4 += 3) < l3);
                return r3;
              };
              this.getDump = function() {
                var BASE = 65521;
                var NMAX = 5552;
                var s1 = 1;
                var s22 = 0;
                var n3 = NMAX;
                for (var y3 = 0; y3 < this.height; y3++) {
                  for (var x3 = -1; x3 < this.width; x3++) {
                    s1 += this.buffer[this.index(x3, y3)].charCodeAt(0);
                    s22 += s1;
                    if ((n3 -= 1) == 0) {
                      s1 %= BASE;
                      s22 %= BASE;
                      n3 = NMAX;
                    }
                  }
                }
                s1 %= BASE;
                s22 %= BASE;
                write(this.buffer, this.idat_offs + this.idat_size - 8, byte4(s22 << 16 | s1));
                function crc32(png, offs, size2) {
                  var crc = -1;
                  for (var i4 = 4; i4 < size2 - 4; i4 += 1) {
                    crc = _crc32[(crc ^ png[offs + i4].charCodeAt(0)) & 255] ^ crc >> 8 & 16777215;
                  }
                  write(png, offs + size2 - 4, byte4(crc ^ -1));
                }
                crc32(this.buffer, this.ihdr_offs, this.ihdr_size);
                crc32(this.buffer, this.plte_offs, this.plte_size);
                crc32(this.buffer, this.trns_offs, this.trns_size);
                crc32(this.buffer, this.idat_offs, this.idat_size);
                crc32(this.buffer, this.iend_offs, this.iend_size);
                return "PNG\r\n\n" + this.buffer.join("");
              };
            };
          },
          /* 2 */
          /***/
          function(module3, exports3) {
            function hue2rgb(p2, q2, t3) {
              if (t3 < 0)
                t3 += 1;
              if (t3 > 1)
                t3 -= 1;
              if (t3 < 1 / 6)
                return p2 + (q2 - p2) * 6 * t3;
              if (t3 < 1 / 2)
                return q2;
              if (t3 < 2 / 3)
                return p2 + (q2 - p2) * (2 / 3 - t3) * 6;
              return p2;
            }
            function hsl2rgb(h2, s3, l3) {
              let r3, g3, b3;
              if (s3 == 0) {
                r3 = g3 = b3 = l3;
              } else {
                const q2 = l3 < 0.5 ? l3 * (1 + s3) : l3 + s3 - l3 * s3;
                const p2 = 2 * l3 - q2;
                r3 = hue2rgb(p2, q2, h2 + 1 / 3);
                g3 = hue2rgb(p2, q2, h2);
                b3 = hue2rgb(p2, q2, h2 - 1 / 3);
              }
              return [Math.round(r3 * 255), Math.round(g3 * 255), Math.round(b3 * 255), 255];
            }
            module3.exports = hsl2rgb;
          }
          /******/
        ])
      );
    });
  }
});

// node_modules/react-is/cjs/react-is.production.min.js
var require_react_is_production_min = __commonJS({
  "node_modules/react-is/cjs/react-is.production.min.js"(exports2) {
    "use strict";
    var import_dist56 = __toESM(require_dist());
    var b3 = "function" === typeof Symbol && Symbol.for;
    var c3 = b3 ? Symbol.for("react.element") : 60103;
    var d3 = b3 ? Symbol.for("react.portal") : 60106;
    var e3 = b3 ? Symbol.for("react.fragment") : 60107;
    var f3 = b3 ? Symbol.for("react.strict_mode") : 60108;
    var g3 = b3 ? Symbol.for("react.profiler") : 60114;
    var h2 = b3 ? Symbol.for("react.provider") : 60109;
    var k2 = b3 ? Symbol.for("react.context") : 60110;
    var l3 = b3 ? Symbol.for("react.async_mode") : 60111;
    var m3 = b3 ? Symbol.for("react.concurrent_mode") : 60111;
    var n3 = b3 ? Symbol.for("react.forward_ref") : 60112;
    var p2 = b3 ? Symbol.for("react.suspense") : 60113;
    var q2 = b3 ? Symbol.for("react.suspense_list") : 60120;
    var r3 = b3 ? Symbol.for("react.memo") : 60115;
    var t3 = b3 ? Symbol.for("react.lazy") : 60116;
    var v3 = b3 ? Symbol.for("react.block") : 60121;
    var w3 = b3 ? Symbol.for("react.fundamental") : 60117;
    var x3 = b3 ? Symbol.for("react.responder") : 60118;
    var y3 = b3 ? Symbol.for("react.scope") : 60119;
    function z2(a3) {
      if ("object" === typeof a3 && null !== a3) {
        var u3 = a3.$$typeof;
        switch (u3) {
          case c3:
            switch (a3 = a3.type, a3) {
              case l3:
              case m3:
              case e3:
              case g3:
              case f3:
              case p2:
                return a3;
              default:
                switch (a3 = a3 && a3.$$typeof, a3) {
                  case k2:
                  case n3:
                  case t3:
                  case r3:
                  case h2:
                    return a3;
                  default:
                    return u3;
                }
            }
          case d3:
            return u3;
        }
      }
    }
    function A(a3) {
      return z2(a3) === m3;
    }
    exports2.AsyncMode = l3;
    exports2.ConcurrentMode = m3;
    exports2.ContextConsumer = k2;
    exports2.ContextProvider = h2;
    exports2.Element = c3;
    exports2.ForwardRef = n3;
    exports2.Fragment = e3;
    exports2.Lazy = t3;
    exports2.Memo = r3;
    exports2.Portal = d3;
    exports2.Profiler = g3;
    exports2.StrictMode = f3;
    exports2.Suspense = p2;
    exports2.isAsyncMode = function(a3) {
      return A(a3) || z2(a3) === l3;
    };
    exports2.isConcurrentMode = A;
    exports2.isContextConsumer = function(a3) {
      return z2(a3) === k2;
    };
    exports2.isContextProvider = function(a3) {
      return z2(a3) === h2;
    };
    exports2.isElement = function(a3) {
      return "object" === typeof a3 && null !== a3 && a3.$$typeof === c3;
    };
    exports2.isForwardRef = function(a3) {
      return z2(a3) === n3;
    };
    exports2.isFragment = function(a3) {
      return z2(a3) === e3;
    };
    exports2.isLazy = function(a3) {
      return z2(a3) === t3;
    };
    exports2.isMemo = function(a3) {
      return z2(a3) === r3;
    };
    exports2.isPortal = function(a3) {
      return z2(a3) === d3;
    };
    exports2.isProfiler = function(a3) {
      return z2(a3) === g3;
    };
    exports2.isStrictMode = function(a3) {
      return z2(a3) === f3;
    };
    exports2.isSuspense = function(a3) {
      return z2(a3) === p2;
    };
    exports2.isValidElementType = function(a3) {
      return "string" === typeof a3 || "function" === typeof a3 || a3 === e3 || a3 === m3 || a3 === g3 || a3 === f3 || a3 === p2 || a3 === q2 || "object" === typeof a3 && null !== a3 && (a3.$$typeof === t3 || a3.$$typeof === r3 || a3.$$typeof === h2 || a3.$$typeof === k2 || a3.$$typeof === n3 || a3.$$typeof === w3 || a3.$$typeof === x3 || a3.$$typeof === y3 || a3.$$typeof === v3);
    };
    exports2.typeOf = z2;
  }
});

// node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "node_modules/react-is/cjs/react-is.development.js"(exports2) {
    "use strict";
    var import_dist56 = __toESM(require_dist());
    if (process.env.NODE_ENV !== "production") {
      (function() {
        "use strict";
        var hasSymbol = typeof Symbol === "function" && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
        function isValidElementType(type) {
          return typeof type === "string" || typeof type === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
          type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
        }
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object.type;
                switch (type) {
                  case REACT_ASYNC_MODE_TYPE:
                  case REACT_CONCURRENT_MODE_TYPE:
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
            }
          }
          return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
        }
        function isConcurrentMode(object) {
          return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
        }
        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        exports2.AsyncMode = AsyncMode;
        exports2.ConcurrentMode = ConcurrentMode;
        exports2.ContextConsumer = ContextConsumer;
        exports2.ContextProvider = ContextProvider;
        exports2.Element = Element;
        exports2.ForwardRef = ForwardRef;
        exports2.Fragment = Fragment;
        exports2.Lazy = Lazy;
        exports2.Memo = Memo;
        exports2.Portal = Portal;
        exports2.Profiler = Profiler;
        exports2.StrictMode = StrictMode;
        exports2.Suspense = Suspense;
        exports2.isAsyncMode = isAsyncMode;
        exports2.isConcurrentMode = isConcurrentMode;
        exports2.isContextConsumer = isContextConsumer;
        exports2.isContextProvider = isContextProvider;
        exports2.isElement = isElement;
        exports2.isForwardRef = isForwardRef;
        exports2.isFragment = isFragment;
        exports2.isLazy = isLazy;
        exports2.isMemo = isMemo;
        exports2.isPortal = isPortal;
        exports2.isProfiler = isProfiler;
        exports2.isStrictMode = isStrictMode;
        exports2.isSuspense = isSuspense;
        exports2.isValidElementType = isValidElementType;
        exports2.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/react-is/index.js
var require_react_is = __commonJS({
  "node_modules/react-is/index.js"(exports2, module2) {
    "use strict";
    var import_dist56 = __toESM(require_dist());
    if (process.env.NODE_ENV === "production") {
      module2.exports = require_react_is_production_min();
    } else {
      module2.exports = require_react_is_development();
    }
  }
});

// node_modules/shallowequal/index.js
var require_shallowequal = __commonJS({
  "node_modules/shallowequal/index.js"(exports2, module2) {
    var import_dist56 = __toESM(require_dist());
    module2.exports = function shallowEqual(objA, objB, compare, compareContext) {
      var ret = compare ? compare.call(compareContext, objA, objB) : void 0;
      if (ret !== void 0) {
        return !!ret;
      }
      if (objA === objB) {
        return true;
      }
      if (typeof objA !== "object" || !objA || typeof objB !== "object" || !objB) {
        return false;
      }
      var keysA = Object.keys(objA);
      var keysB = Object.keys(objB);
      if (keysA.length !== keysB.length) {
        return false;
      }
      var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);
      for (var idx = 0; idx < keysA.length; idx++) {
        var key = keysA[idx];
        if (!bHasOwnProperty(key)) {
          return false;
        }
        var valueA = objA[key];
        var valueB = objB[key];
        ret = compare ? compare.call(compareContext, valueA, valueB, key) : void 0;
        if (ret === false || ret === void 0 && valueA !== valueB) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js
var require_hoist_non_react_statics_cjs = __commonJS({
  "node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js"(exports2, module2) {
    "use strict";
    var import_dist56 = __toESM(require_dist());
    var reactIs = require_react_is();
    var REACT_STATICS = {
      childContextTypes: true,
      contextType: true,
      contextTypes: true,
      defaultProps: true,
      displayName: true,
      getDefaultProps: true,
      getDerivedStateFromError: true,
      getDerivedStateFromProps: true,
      mixins: true,
      propTypes: true,
      type: true
    };
    var KNOWN_STATICS = {
      name: true,
      length: true,
      prototype: true,
      caller: true,
      callee: true,
      arguments: true,
      arity: true
    };
    var FORWARD_REF_STATICS = {
      "$$typeof": true,
      render: true,
      defaultProps: true,
      displayName: true,
      propTypes: true
    };
    var MEMO_STATICS = {
      "$$typeof": true,
      compare: true,
      defaultProps: true,
      displayName: true,
      propTypes: true,
      type: true
    };
    var TYPE_STATICS = {};
    TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
    TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
    function getStatics(component) {
      if (reactIs.isMemo(component)) {
        return MEMO_STATICS;
      }
      return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
    }
    var defineProperty = Object.defineProperty;
    var getOwnPropertyNames = Object.getOwnPropertyNames;
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var getPrototypeOf = Object.getPrototypeOf;
    var objectPrototype = Object.prototype;
    function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
      if (typeof sourceComponent !== "string") {
        if (objectPrototype) {
          var inheritedComponent = getPrototypeOf(sourceComponent);
          if (inheritedComponent && inheritedComponent !== objectPrototype) {
            hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
          }
        }
        var keys = getOwnPropertyNames(sourceComponent);
        if (getOwnPropertySymbols) {
          keys = keys.concat(getOwnPropertySymbols(sourceComponent));
        }
        var targetStatics = getStatics(targetComponent);
        var sourceStatics = getStatics(sourceComponent);
        for (var i3 = 0; i3 < keys.length; ++i3) {
          var key = keys[i3];
          if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
            var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
            try {
              defineProperty(targetComponent, key, descriptor);
            } catch (e3) {
            }
          }
        }
      }
      return targetComponent;
    }
    module2.exports = hoistNonReactStatics;
  }
});

// node_modules/toggle-selection/index.js
var require_toggle_selection = __commonJS({
  "node_modules/toggle-selection/index.js"(exports2, module2) {
    var import_dist56 = __toESM(require_dist());
    module2.exports = function() {
      var selection = document.getSelection();
      if (!selection.rangeCount) {
        return function() {
        };
      }
      var active = document.activeElement;
      var ranges = [];
      for (var i3 = 0; i3 < selection.rangeCount; i3++) {
        ranges.push(selection.getRangeAt(i3));
      }
      switch (active.tagName.toUpperCase()) {
        case "INPUT":
        case "TEXTAREA":
          active.blur();
          break;
        default:
          active = null;
          break;
      }
      selection.removeAllRanges();
      return function() {
        selection.type === "Caret" && selection.removeAllRanges();
        if (!selection.rangeCount) {
          ranges.forEach(function(range) {
            selection.addRange(range);
          });
        }
        active && active.focus();
      };
    };
  }
});

// node_modules/copy-to-clipboard/index.js
var require_copy_to_clipboard = __commonJS({
  "node_modules/copy-to-clipboard/index.js"(exports2, module2) {
    "use strict";
    var import_dist56 = __toESM(require_dist());
    var deselectCurrent = require_toggle_selection();
    var clipboardToIE11Formatting = {
      "text/plain": "Text",
      "text/html": "Url",
      "default": "Text"
    };
    var defaultMessage = "Copy to clipboard: #{key}, Enter";
    function format(message) {
      var copyKey = (/mac os x/i.test(navigator.userAgent) ? "⌘" : "Ctrl") + "+C";
      return message.replace(/#{\s*key\s*}/g, copyKey);
    }
    function copy(text2, options) {
      var debug, message, reselectPrevious, range, selection, mark, success = false;
      if (!options) {
        options = {};
      }
      debug = options.debug || false;
      try {
        reselectPrevious = deselectCurrent();
        range = document.createRange();
        selection = document.getSelection();
        mark = document.createElement("span");
        mark.textContent = text2;
        mark.ariaHidden = "true";
        mark.style.all = "unset";
        mark.style.position = "fixed";
        mark.style.top = 0;
        mark.style.clip = "rect(0, 0, 0, 0)";
        mark.style.whiteSpace = "pre";
        mark.style.webkitUserSelect = "text";
        mark.style.MozUserSelect = "text";
        mark.style.msUserSelect = "text";
        mark.style.userSelect = "text";
        mark.addEventListener("copy", function(e3) {
          e3.stopPropagation();
          if (options.format) {
            e3.preventDefault();
            if (typeof e3.clipboardData === "undefined") {
              debug && console.warn("unable to use e.clipboardData");
              debug && console.warn("trying IE specific stuff");
              window.clipboardData.clearData();
              var format2 = clipboardToIE11Formatting[options.format] || clipboardToIE11Formatting["default"];
              window.clipboardData.setData(format2, text2);
            } else {
              e3.clipboardData.clearData();
              e3.clipboardData.setData(options.format, text2);
            }
          }
          if (options.onCopy) {
            e3.preventDefault();
            options.onCopy(e3.clipboardData);
          }
        });
        document.body.appendChild(mark);
        range.selectNodeContents(mark);
        selection.addRange(range);
        var successful = document.execCommand("copy");
        if (!successful) {
          throw new Error("copy command was unsuccessful");
        }
        success = true;
      } catch (err) {
        debug && console.error("unable to copy using execCommand: ", err);
        debug && console.warn("trying IE specific stuff");
        try {
          window.clipboardData.setData(options.format || "text", text2);
          options.onCopy && options.onCopy(window.clipboardData);
          success = true;
        } catch (err2) {
          debug && console.error("unable to copy using clipboardData: ", err2);
          debug && console.error("falling back to prompt");
          message = format("message" in options ? options.message : defaultMessage);
          window.prompt(message, text2);
        }
      } finally {
        if (selection) {
          if (typeof selection.removeRange == "function") {
            selection.removeRange(range);
          } else {
            selection.removeAllRanges();
          }
        }
        if (mark) {
          document.body.removeChild(mark);
        }
        reselectPrevious();
      }
      return success;
    }
    module2.exports = copy;
  }
});

// node_modules/react-copy-to-clipboard/lib/Component.js
var require_Component = __commonJS({
  "node_modules/react-copy-to-clipboard/lib/Component.js"(exports2) {
    "use strict";
    var import_dist56 = __toESM(require_dist());
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof(obj);
    }
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.CopyToClipboard = void 0;
    var _react = _interopRequireDefault(require_react());
    var _copyToClipboard = _interopRequireDefault(require_copy_to_clipboard());
    var _excluded = ["text", "onCopy", "options", "children"];
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i3 = 1; i3 < arguments.length; i3++) {
        var source = null != arguments[i3] ? arguments[i3] : {};
        i3 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _objectWithoutProperties(source, excluded) {
      if (source == null)
        return {};
      var target = _objectWithoutPropertiesLoose(source, excluded);
      var key, i3;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i3 = 0; i3 < sourceSymbolKeys.length; i3++) {
          key = sourceSymbolKeys[i3];
          if (excluded.indexOf(key) >= 0)
            continue;
          if (!Object.prototype.propertyIsEnumerable.call(source, key))
            continue;
          target[key] = source[key];
        }
      }
      return target;
    }
    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null)
        return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i3;
      for (i3 = 0; i3 < sourceKeys.length; i3++) {
        key = sourceKeys[i3];
        if (excluded.indexOf(key) >= 0)
          continue;
        target[key] = source[key];
      }
      return target;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i3 = 0; i3 < props.length; i3++) {
        var descriptor = props[i3];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      Object.defineProperty(subClass, "prototype", { writable: false });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o3, p2) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o4, p3) {
        o4.__proto__ = p3;
        return o4;
      };
      return _setPrototypeOf(o3, p2);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e3) {
        return false;
      }
    }
    function _getPrototypeOf(o3) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o4) {
        return o4.__proto__ || Object.getPrototypeOf(o4);
      };
      return _getPrototypeOf(o3);
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var CopyToClipboard2 = function(_React$PureComponent) {
      _inherits(CopyToClipboard3, _React$PureComponent);
      var _super = _createSuper(CopyToClipboard3);
      function CopyToClipboard3() {
        var _this;
        _classCallCheck(this, CopyToClipboard3);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "onClick", function(event) {
          var _this$props = _this.props, text2 = _this$props.text, onCopy = _this$props.onCopy, children = _this$props.children, options = _this$props.options;
          var elem = _react["default"].Children.only(children);
          var result = (0, _copyToClipboard["default"])(text2, options);
          if (onCopy) {
            onCopy(text2, result);
          }
          if (elem && elem.props && typeof elem.props.onClick === "function") {
            elem.props.onClick(event);
          }
        });
        return _this;
      }
      _createClass(CopyToClipboard3, [{
        key: "render",
        value: function render() {
          var _this$props2 = this.props, _text = _this$props2.text, _onCopy = _this$props2.onCopy, _options = _this$props2.options, children = _this$props2.children, props = _objectWithoutProperties(_this$props2, _excluded);
          var elem = _react["default"].Children.only(children);
          return _react["default"].cloneElement(elem, _objectSpread(_objectSpread({}, props), {}, {
            onClick: this.onClick
          }));
        }
      }]);
      return CopyToClipboard3;
    }(_react["default"].PureComponent);
    exports2.CopyToClipboard = CopyToClipboard2;
    _defineProperty(CopyToClipboard2, "defaultProps", {
      onCopy: void 0,
      options: void 0
    });
  }
});

// node_modules/react-copy-to-clipboard/lib/index.js
var require_lib = __commonJS({
  "node_modules/react-copy-to-clipboard/lib/index.js"(exports2, module2) {
    "use strict";
    var import_dist56 = __toESM(require_dist());
    var _require = require_Component();
    var CopyToClipboard2 = _require.CopyToClipboard;
    CopyToClipboard2.CopyToClipboard = CopyToClipboard2;
    module2.exports = CopyToClipboard2;
  }
});

// node_modules/store/src/util.js
var require_util = __commonJS({
  "node_modules/store/src/util.js"(exports2, module2) {
    var import_dist56 = __toESM(require_dist());
    var assign = make_assign();
    var create = make_create();
    var trim = make_trim();
    var Global = typeof window !== "undefined" ? window : global;
    module2.exports = {
      assign,
      create,
      trim,
      bind,
      slice,
      each,
      map,
      pluck,
      isList,
      isFunction,
      isObject,
      Global
    };
    function make_assign() {
      if (Object.assign) {
        return Object.assign;
      } else {
        return function shimAssign(obj, props1, props2, etc) {
          for (var i3 = 1; i3 < arguments.length; i3++) {
            each(Object(arguments[i3]), function(val, key) {
              obj[key] = val;
            });
          }
          return obj;
        };
      }
    }
    function make_create() {
      if (Object.create) {
        return function create2(obj, assignProps1, assignProps2, etc) {
          var assignArgsList = slice(arguments, 1);
          return assign.apply(this, [Object.create(obj)].concat(assignArgsList));
        };
      } else {
        let F3 = function() {
        };
        var F2 = F3;
        return function create2(obj, assignProps1, assignProps2, etc) {
          var assignArgsList = slice(arguments, 1);
          F3.prototype = obj;
          return assign.apply(this, [new F3()].concat(assignArgsList));
        };
      }
    }
    function make_trim() {
      if (String.prototype.trim) {
        return function trim2(str2) {
          return String.prototype.trim.call(str2);
        };
      } else {
        return function trim2(str2) {
          return str2.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
        };
      }
    }
    function bind(obj, fn) {
      return function() {
        return fn.apply(obj, Array.prototype.slice.call(arguments, 0));
      };
    }
    function slice(arr, index) {
      return Array.prototype.slice.call(arr, index || 0);
    }
    function each(obj, fn) {
      pluck(obj, function(val, key) {
        fn(val, key);
        return false;
      });
    }
    function map(obj, fn) {
      var res = isList(obj) ? [] : {};
      pluck(obj, function(v3, k2) {
        res[k2] = fn(v3, k2);
        return false;
      });
      return res;
    }
    function pluck(obj, fn) {
      if (isList(obj)) {
        for (var i3 = 0; i3 < obj.length; i3++) {
          if (fn(obj[i3], i3)) {
            return obj[i3];
          }
        }
      } else {
        for (var key in obj) {
          if (obj.hasOwnProperty(key)) {
            if (fn(obj[key], key)) {
              return obj[key];
            }
          }
        }
      }
    }
    function isList(val) {
      return val != null && typeof val != "function" && typeof val.length == "number";
    }
    function isFunction(val) {
      return val && {}.toString.call(val) === "[object Function]";
    }
    function isObject(val) {
      return val && {}.toString.call(val) === "[object Object]";
    }
  }
});

// node_modules/store/src/store-engine.js
var require_store_engine = __commonJS({
  "node_modules/store/src/store-engine.js"(exports2, module2) {
    var import_dist56 = __toESM(require_dist());
    var util = require_util();
    var slice = util.slice;
    var pluck = util.pluck;
    var each = util.each;
    var bind = util.bind;
    var create = util.create;
    var isList = util.isList;
    var isFunction = util.isFunction;
    var isObject = util.isObject;
    module2.exports = {
      createStore
    };
    var storeAPI = {
      version: "2.0.12",
      enabled: false,
      // get returns the value of the given key. If that value
      // is undefined, it returns optionalDefaultValue instead.
      get: function(key, optionalDefaultValue) {
        var data = this.storage.read(this._namespacePrefix + key);
        return this._deserialize(data, optionalDefaultValue);
      },
      // set will store the given value at key and returns value.
      // Calling set with value === undefined is equivalent to calling remove.
      set: function(key, value) {
        if (value === void 0) {
          return this.remove(key);
        }
        this.storage.write(this._namespacePrefix + key, this._serialize(value));
        return value;
      },
      // remove deletes the key and value stored at the given key.
      remove: function(key) {
        this.storage.remove(this._namespacePrefix + key);
      },
      // each will call the given callback once for each key-value pair
      // in this store.
      each: function(callback) {
        var self2 = this;
        this.storage.each(function(val, namespacedKey) {
          callback.call(self2, self2._deserialize(val), (namespacedKey || "").replace(self2._namespaceRegexp, ""));
        });
      },
      // clearAll will remove all the stored key-value pairs in this store.
      clearAll: function() {
        this.storage.clearAll();
      },
      // additional functionality that can't live in plugins
      // ---------------------------------------------------
      // hasNamespace returns true if this store instance has the given namespace.
      hasNamespace: function(namespace) {
        return this._namespacePrefix == "__storejs_" + namespace + "_";
      },
      // createStore creates a store.js instance with the first
      // functioning storage in the list of storage candidates,
      // and applies the the given mixins to the instance.
      createStore: function() {
        return createStore.apply(this, arguments);
      },
      addPlugin: function(plugin) {
        this._addPlugin(plugin);
      },
      namespace: function(namespace) {
        return createStore(this.storage, this.plugins, namespace);
      }
    };
    function _warn() {
      var _console = typeof console == "undefined" ? null : console;
      if (!_console) {
        return;
      }
      var fn = _console.warn ? _console.warn : _console.log;
      fn.apply(_console, arguments);
    }
    function createStore(storages, plugins, namespace) {
      if (!namespace) {
        namespace = "";
      }
      if (storages && !isList(storages)) {
        storages = [storages];
      }
      if (plugins && !isList(plugins)) {
        plugins = [plugins];
      }
      var namespacePrefix = namespace ? "__storejs_" + namespace + "_" : "";
      var namespaceRegexp = namespace ? new RegExp("^" + namespacePrefix) : null;
      var legalNamespaces = /^[a-zA-Z0-9_\-]*$/;
      if (!legalNamespaces.test(namespace)) {
        throw new Error("store.js namespaces can only have alphanumerics + underscores and dashes");
      }
      var _privateStoreProps = {
        _namespacePrefix: namespacePrefix,
        _namespaceRegexp: namespaceRegexp,
        _testStorage: function(storage) {
          try {
            var testStr = "__storejs__test__";
            storage.write(testStr, testStr);
            var ok = storage.read(testStr) === testStr;
            storage.remove(testStr);
            return ok;
          } catch (e3) {
            return false;
          }
        },
        _assignPluginFnProp: function(pluginFnProp, propName) {
          var oldFn = this[propName];
          this[propName] = function pluginFn() {
            var args = slice(arguments, 0);
            var self2 = this;
            function super_fn() {
              if (!oldFn) {
                return;
              }
              each(arguments, function(arg, i3) {
                args[i3] = arg;
              });
              return oldFn.apply(self2, args);
            }
            var newFnArgs = [super_fn].concat(args);
            return pluginFnProp.apply(self2, newFnArgs);
          };
        },
        _serialize: function(obj) {
          return JSON.stringify(obj);
        },
        _deserialize: function(strVal, defaultVal) {
          if (!strVal) {
            return defaultVal;
          }
          var val = "";
          try {
            val = JSON.parse(strVal);
          } catch (e3) {
            val = strVal;
          }
          return val !== void 0 ? val : defaultVal;
        },
        _addStorage: function(storage) {
          if (this.enabled) {
            return;
          }
          if (this._testStorage(storage)) {
            this.storage = storage;
            this.enabled = true;
          }
        },
        _addPlugin: function(plugin) {
          var self2 = this;
          if (isList(plugin)) {
            each(plugin, function(plugin2) {
              self2._addPlugin(plugin2);
            });
            return;
          }
          var seenPlugin = pluck(this.plugins, function(seenPlugin2) {
            return plugin === seenPlugin2;
          });
          if (seenPlugin) {
            return;
          }
          this.plugins.push(plugin);
          if (!isFunction(plugin)) {
            throw new Error("Plugins must be function values that return objects");
          }
          var pluginProperties = plugin.call(this);
          if (!isObject(pluginProperties)) {
            throw new Error("Plugins must return an object of function properties");
          }
          each(pluginProperties, function(pluginFnProp, propName) {
            if (!isFunction(pluginFnProp)) {
              throw new Error("Bad plugin property: " + propName + " from plugin " + plugin.name + ". Plugins should only return functions.");
            }
            self2._assignPluginFnProp(pluginFnProp, propName);
          });
        },
        // Put deprecated properties in the private API, so as to not expose it to accidential
        // discovery through inspection of the store object.
        // Deprecated: addStorage
        addStorage: function(storage) {
          _warn("store.addStorage(storage) is deprecated. Use createStore([storages])");
          this._addStorage(storage);
        }
      };
      var store2 = create(_privateStoreProps, storeAPI, {
        plugins: []
      });
      store2.raw = {};
      each(store2, function(prop, propName) {
        if (isFunction(prop)) {
          store2.raw[propName] = bind(store2, prop);
        }
      });
      each(storages, function(storage) {
        store2._addStorage(storage);
      });
      each(plugins, function(plugin) {
        store2._addPlugin(plugin);
      });
      return store2;
    }
  }
});

// node_modules/store/storages/localStorage.js
var require_localStorage = __commonJS({
  "node_modules/store/storages/localStorage.js"(exports2, module2) {
    var import_dist56 = __toESM(require_dist());
    var util = require_util();
    var Global = util.Global;
    module2.exports = {
      name: "localStorage",
      read,
      write,
      each,
      remove,
      clearAll
    };
    function localStorage() {
      return Global.localStorage;
    }
    function read(key) {
      return localStorage().getItem(key);
    }
    function write(key, data) {
      return localStorage().setItem(key, data);
    }
    function each(fn) {
      for (var i3 = localStorage().length - 1; i3 >= 0; i3--) {
        var key = localStorage().key(i3);
        fn(read(key), key);
      }
    }
    function remove(key) {
      return localStorage().removeItem(key);
    }
    function clearAll() {
      return localStorage().clear();
    }
  }
});

// node_modules/store/storages/oldFF-globalStorage.js
var require_oldFF_globalStorage = __commonJS({
  "node_modules/store/storages/oldFF-globalStorage.js"(exports2, module2) {
    var import_dist56 = __toESM(require_dist());
    var util = require_util();
    var Global = util.Global;
    module2.exports = {
      name: "oldFF-globalStorage",
      read,
      write,
      each,
      remove,
      clearAll
    };
    var globalStorage = Global.globalStorage;
    function read(key) {
      return globalStorage[key];
    }
    function write(key, data) {
      globalStorage[key] = data;
    }
    function each(fn) {
      for (var i3 = globalStorage.length - 1; i3 >= 0; i3--) {
        var key = globalStorage.key(i3);
        fn(globalStorage[key], key);
      }
    }
    function remove(key) {
      return globalStorage.removeItem(key);
    }
    function clearAll() {
      each(function(key, _2) {
        delete globalStorage[key];
      });
    }
  }
});

// node_modules/store/storages/oldIE-userDataStorage.js
var require_oldIE_userDataStorage = __commonJS({
  "node_modules/store/storages/oldIE-userDataStorage.js"(exports2, module2) {
    var import_dist56 = __toESM(require_dist());
    var util = require_util();
    var Global = util.Global;
    module2.exports = {
      name: "oldIE-userDataStorage",
      write,
      read,
      each,
      remove,
      clearAll
    };
    var storageName = "storejs";
    var doc = Global.document;
    var _withStorageEl = _makeIEStorageElFunction();
    var disable = (Global.navigator ? Global.navigator.userAgent : "").match(/ (MSIE 8|MSIE 9|MSIE 10)\./);
    function write(unfixedKey, data) {
      if (disable) {
        return;
      }
      var fixedKey = fixKey(unfixedKey);
      _withStorageEl(function(storageEl) {
        storageEl.setAttribute(fixedKey, data);
        storageEl.save(storageName);
      });
    }
    function read(unfixedKey) {
      if (disable) {
        return;
      }
      var fixedKey = fixKey(unfixedKey);
      var res = null;
      _withStorageEl(function(storageEl) {
        res = storageEl.getAttribute(fixedKey);
      });
      return res;
    }
    function each(callback) {
      _withStorageEl(function(storageEl) {
        var attributes = storageEl.XMLDocument.documentElement.attributes;
        for (var i3 = attributes.length - 1; i3 >= 0; i3--) {
          var attr = attributes[i3];
          callback(storageEl.getAttribute(attr.name), attr.name);
        }
      });
    }
    function remove(unfixedKey) {
      var fixedKey = fixKey(unfixedKey);
      _withStorageEl(function(storageEl) {
        storageEl.removeAttribute(fixedKey);
        storageEl.save(storageName);
      });
    }
    function clearAll() {
      _withStorageEl(function(storageEl) {
        var attributes = storageEl.XMLDocument.documentElement.attributes;
        storageEl.load(storageName);
        for (var i3 = attributes.length - 1; i3 >= 0; i3--) {
          storageEl.removeAttribute(attributes[i3].name);
        }
        storageEl.save(storageName);
      });
    }
    var forbiddenCharsRegex = new RegExp("[!\"#$%&'()*+,/\\\\:;<=>?@[\\]^`{|}~]", "g");
    function fixKey(key) {
      return key.replace(/^\d/, "___$&").replace(forbiddenCharsRegex, "___");
    }
    function _makeIEStorageElFunction() {
      if (!doc || !doc.documentElement || !doc.documentElement.addBehavior) {
        return null;
      }
      var scriptTag = "script", storageOwner, storageContainer, storageEl;
      try {
        storageContainer = new ActiveXObject("htmlfile");
        storageContainer.open();
        storageContainer.write("<" + scriptTag + ">document.w=window</" + scriptTag + '><iframe src="/favicon.ico"></iframe>');
        storageContainer.close();
        storageOwner = storageContainer.w.frames[0].document;
        storageEl = storageOwner.createElement("div");
      } catch (e3) {
        storageEl = doc.createElement("div");
        storageOwner = doc.body;
      }
      return function(storeFunction) {
        var args = [].slice.call(arguments, 0);
        args.unshift(storageEl);
        storageOwner.appendChild(storageEl);
        storageEl.addBehavior("#default#userData");
        storageEl.load(storageName);
        storeFunction.apply(this, args);
        storageOwner.removeChild(storageEl);
        return;
      };
    }
  }
});

// node_modules/store/storages/cookieStorage.js
var require_cookieStorage = __commonJS({
  "node_modules/store/storages/cookieStorage.js"(exports2, module2) {
    var import_dist56 = __toESM(require_dist());
    var util = require_util();
    var Global = util.Global;
    var trim = util.trim;
    module2.exports = {
      name: "cookieStorage",
      read,
      write,
      each,
      remove,
      clearAll
    };
    var doc = Global.document;
    function read(key) {
      if (!key || !_has(key)) {
        return null;
      }
      var regexpStr = "(?:^|.*;\\s*)" + escape(key).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=\\s*((?:[^;](?!;))*[^;]?).*";
      return unescape(doc.cookie.replace(new RegExp(regexpStr), "$1"));
    }
    function each(callback) {
      var cookies = doc.cookie.split(/; ?/g);
      for (var i3 = cookies.length - 1; i3 >= 0; i3--) {
        if (!trim(cookies[i3])) {
          continue;
        }
        var kvp = cookies[i3].split("=");
        var key = unescape(kvp[0]);
        var val = unescape(kvp[1]);
        callback(val, key);
      }
    }
    function write(key, data) {
      if (!key) {
        return;
      }
      doc.cookie = escape(key) + "=" + escape(data) + "; expires=Tue, 19 Jan 2038 03:14:07 GMT; path=/";
    }
    function remove(key) {
      if (!key || !_has(key)) {
        return;
      }
      doc.cookie = escape(key) + "=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/";
    }
    function clearAll() {
      each(function(_2, key) {
        remove(key);
      });
    }
    function _has(key) {
      return new RegExp("(?:^|;\\s*)" + escape(key).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=").test(doc.cookie);
    }
  }
});

// node_modules/store/storages/sessionStorage.js
var require_sessionStorage = __commonJS({
  "node_modules/store/storages/sessionStorage.js"(exports2, module2) {
    var import_dist56 = __toESM(require_dist());
    var util = require_util();
    var Global = util.Global;
    module2.exports = {
      name: "sessionStorage",
      read,
      write,
      each,
      remove,
      clearAll
    };
    function sessionStorage() {
      return Global.sessionStorage;
    }
    function read(key) {
      return sessionStorage().getItem(key);
    }
    function write(key, data) {
      return sessionStorage().setItem(key, data);
    }
    function each(fn) {
      for (var i3 = sessionStorage().length - 1; i3 >= 0; i3--) {
        var key = sessionStorage().key(i3);
        fn(read(key), key);
      }
    }
    function remove(key) {
      return sessionStorage().removeItem(key);
    }
    function clearAll() {
      return sessionStorage().clear();
    }
  }
});

// node_modules/store/storages/memoryStorage.js
var require_memoryStorage = __commonJS({
  "node_modules/store/storages/memoryStorage.js"(exports2, module2) {
    var import_dist56 = __toESM(require_dist());
    module2.exports = {
      name: "memoryStorage",
      read,
      write,
      each,
      remove,
      clearAll
    };
    var memoryStorage = {};
    function read(key) {
      return memoryStorage[key];
    }
    function write(key, data) {
      memoryStorage[key] = data;
    }
    function each(callback) {
      for (var key in memoryStorage) {
        if (memoryStorage.hasOwnProperty(key)) {
          callback(memoryStorage[key], key);
        }
      }
    }
    function remove(key) {
      delete memoryStorage[key];
    }
    function clearAll(key) {
      memoryStorage = {};
    }
  }
});

// node_modules/store/storages/all.js
var require_all = __commonJS({
  "node_modules/store/storages/all.js"(exports2, module2) {
    var import_dist56 = __toESM(require_dist());
    module2.exports = [
      // Listed in order of usage preference
      require_localStorage(),
      require_oldFF_globalStorage(),
      require_oldIE_userDataStorage(),
      require_cookieStorage(),
      require_sessionStorage(),
      require_memoryStorage()
    ];
  }
});

// node_modules/store/plugins/lib/json2.js
var require_json2 = __commonJS({
  "node_modules/store/plugins/lib/json2.js"(exports, module) {
    var import_dist56 = __toESM(require_dist());
    if (typeof JSON !== "object") {
      JSON = {};
    }
    (function() {
      "use strict";
      var rx_one = /^[\],:{}\s]*$/;
      var rx_two = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g;
      var rx_three = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
      var rx_four = /(?:^|:|,)(?:\s*\[)+/g;
      var rx_escapable = /[\\"\u0000-\u001f\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
      var rx_dangerous = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
      function f(n3) {
        return n3 < 10 ? "0" + n3 : n3;
      }
      function this_value() {
        return this.valueOf();
      }
      if (typeof Date.prototype.toJSON !== "function") {
        Date.prototype.toJSON = function() {
          return isFinite(this.valueOf()) ? this.getUTCFullYear() + "-" + f(this.getUTCMonth() + 1) + "-" + f(this.getUTCDate()) + "T" + f(this.getUTCHours()) + ":" + f(this.getUTCMinutes()) + ":" + f(this.getUTCSeconds()) + "Z" : null;
        };
        Boolean.prototype.toJSON = this_value;
        Number.prototype.toJSON = this_value;
        String.prototype.toJSON = this_value;
      }
      var gap;
      var indent;
      var meta;
      var rep;
      function quote(string) {
        rx_escapable.lastIndex = 0;
        return rx_escapable.test(string) ? '"' + string.replace(rx_escapable, function(a3) {
          var c3 = meta[a3];
          return typeof c3 === "string" ? c3 : "\\u" + ("0000" + a3.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
      }
      function str(key, holder) {
        var i3;
        var k2;
        var v3;
        var length;
        var mind = gap;
        var partial;
        var value = holder[key];
        if (value && typeof value === "object" && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        if (typeof rep === "function") {
          value = rep.call(holder, key, value);
        }
        switch (typeof value) {
          case "string":
            return quote(value);
          case "number":
            return isFinite(value) ? String(value) : "null";
          case "boolean":
          case "null":
            return String(value);
          case "object":
            if (!value) {
              return "null";
            }
            gap += indent;
            partial = [];
            if (Object.prototype.toString.apply(value) === "[object Array]") {
              length = value.length;
              for (i3 = 0; i3 < length; i3 += 1) {
                partial[i3] = str(i3, value) || "null";
              }
              v3 = partial.length === 0 ? "[]" : gap ? "[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]" : "[" + partial.join(",") + "]";
              gap = mind;
              return v3;
            }
            if (rep && typeof rep === "object") {
              length = rep.length;
              for (i3 = 0; i3 < length; i3 += 1) {
                if (typeof rep[i3] === "string") {
                  k2 = rep[i3];
                  v3 = str(k2, value);
                  if (v3) {
                    partial.push(quote(k2) + (gap ? ": " : ":") + v3);
                  }
                }
              }
            } else {
              for (k2 in value) {
                if (Object.prototype.hasOwnProperty.call(value, k2)) {
                  v3 = str(k2, value);
                  if (v3) {
                    partial.push(quote(k2) + (gap ? ": " : ":") + v3);
                  }
                }
              }
            }
            v3 = partial.length === 0 ? "{}" : gap ? "{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}" : "{" + partial.join(",") + "}";
            gap = mind;
            return v3;
        }
      }
      if (typeof JSON.stringify !== "function") {
        meta = {
          // table of character substitutions
          "\b": "\\b",
          "	": "\\t",
          "\n": "\\n",
          "\f": "\\f",
          "\r": "\\r",
          '"': '\\"',
          "\\": "\\\\"
        };
        JSON.stringify = function(value, replacer, space) {
          var i3;
          gap = "";
          indent = "";
          if (typeof space === "number") {
            for (i3 = 0; i3 < space; i3 += 1) {
              indent += " ";
            }
          } else if (typeof space === "string") {
            indent = space;
          }
          rep = replacer;
          if (replacer && typeof replacer !== "function" && (typeof replacer !== "object" || typeof replacer.length !== "number")) {
            throw new Error("JSON.stringify");
          }
          return str("", { "": value });
        };
      }
      if (typeof JSON.parse !== "function") {
        JSON.parse = function(text, reviver) {
          var j;
          function walk(holder, key) {
            var k2;
            var v3;
            var value = holder[key];
            if (value && typeof value === "object") {
              for (k2 in value) {
                if (Object.prototype.hasOwnProperty.call(value, k2)) {
                  v3 = walk(value, k2);
                  if (v3 !== void 0) {
                    value[k2] = v3;
                  } else {
                    delete value[k2];
                  }
                }
              }
            }
            return reviver.call(holder, key, value);
          }
          text = String(text);
          rx_dangerous.lastIndex = 0;
          if (rx_dangerous.test(text)) {
            text = text.replace(rx_dangerous, function(a3) {
              return "\\u" + ("0000" + a3.charCodeAt(0).toString(16)).slice(-4);
            });
          }
          if (rx_one.test(
            text.replace(rx_two, "@").replace(rx_three, "]").replace(rx_four, "")
          )) {
            j = eval("(" + text + ")");
            return typeof reviver === "function" ? walk({ "": j }, "") : j;
          }
          throw new SyntaxError("JSON.parse");
        };
      }
    })();
  }
});

// node_modules/store/plugins/json2.js
var require_json22 = __commonJS({
  "node_modules/store/plugins/json2.js"(exports2, module2) {
    var import_dist56 = __toESM(require_dist());
    module2.exports = json2Plugin;
    function json2Plugin() {
      require_json2();
      return {};
    }
  }
});

// node_modules/store/dist/store.legacy.js
var require_store_legacy = __commonJS({
  "node_modules/store/dist/store.legacy.js"(exports2, module2) {
    var import_dist56 = __toESM(require_dist());
    var engine = require_store_engine();
    var storages = require_all();
    var plugins = [require_json22()];
    module2.exports = engine.createStore(storages, plugins);
  }
});

// node_modules/@polkadot/react-identicon/index.js
var import_dist55 = __toESM(require_dist());

// node_modules/@polkadot/react-identicon/detectPackage.js
var import_dist5 = __toESM(require_dist(), 1);

// node_modules/@polkadot/react-identicon/detectOther.js
var import_dist3 = __toESM(require_dist(), 1);

// node_modules/@polkadot/ui-settings/packageInfo.js
var import_dist = __toESM(require_dist());
var packageInfo = { name: "@polkadot/ui-settings", path: import.meta && import.meta.url ? new URL(import.meta.url).pathname.substring(0, new URL(import.meta.url).pathname.lastIndexOf("/") + 1) : "auto", type: "esm", version: "3.1.4" };

// node_modules/@polkadot/ui-shared/packageInfo.js
var import_dist2 = __toESM(require_dist());
var packageInfo2 = { name: "@polkadot/ui-shared", path: import.meta && import.meta.url ? new URL(import.meta.url).pathname.substring(0, new URL(import.meta.url).pathname.lastIndexOf("/") + 1) : "auto", type: "esm", version: "3.1.4" };

// node_modules/@polkadot/react-identicon/detectOther.js
var detectOther_default = [packageInfo, packageInfo2];

// node_modules/@polkadot/react-identicon/packageInfo.js
var import_dist4 = __toESM(require_dist(), 1);
var packageInfo3 = { name: "@polkadot/react-identicon", path: import.meta && import.meta.url ? new URL(import.meta.url).pathname.substring(0, new URL(import.meta.url).pathname.lastIndexOf("/") + 1) : "auto", type: "esm", version: "3.1.4" };

// node_modules/@polkadot/react-identicon/detectPackage.js
detectPackage(packageInfo3, null, detectOther_default);

// node_modules/@polkadot/react-identicon/bundle.js
var import_dist54 = __toESM(require_dist(), 1);

// node_modules/@polkadot/react-identicon/icons/index.js
var import_dist33 = __toESM(require_dist(), 1);

// node_modules/@polkadot/react-identicon/icons/Beachball.js
var import_dist22 = __toESM(require_dist(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var import_react = __toESM(require_react(), 1);

// node_modules/@polkadot/ui-shared/index.js
var import_dist21 = __toESM(require_dist());

// node_modules/@polkadot/ui-shared/detectPackage.js
var import_dist7 = __toESM(require_dist(), 1);

// node_modules/@polkadot/ui-shared/detectOther.js
var import_dist6 = __toESM(require_dist(), 1);
var detectOther_default2 = [];

// node_modules/@polkadot/ui-shared/detectPackage.js
detectPackage(packageInfo2, null, detectOther_default2);

// node_modules/@polkadot/ui-shared/bundle.js
var import_dist20 = __toESM(require_dist(), 1);

// node_modules/@polkadot/ui-shared/icons/index.js
var import_dist19 = __toESM(require_dist(), 1);

// node_modules/@polkadot/ui-shared/icons/beachball/index.js
var import_dist17 = __toESM(require_dist(), 1);

// node_modules/@polkadot/ui-shared/icons/beachball/shape/circle.js
var import_dist11 = __toESM(require_dist(), 1);

// node_modules/@polkadot/ui-shared/icons/beachball/defaults.js
var import_dist8 = __toESM(require_dist(), 1);
var COLORS = [
  // https://sashat.me/2017/01/11/list-of-20-simple-distinct-colors/
  "#ffe119",
  "#4363d8",
  "#f58231",
  "#fabebe",
  "#e6beff",
  "#800000",
  "#000075",
  "#a9a9a9",
  "#ffffff",
  "#000000"
];
var SHAPE_COUNT = 5;

// node_modules/@polkadot/ui-shared/icons/beachball/svg/circle.js
var import_dist10 = __toESM(require_dist(), 1);

// node_modules/@polkadot/ui-shared/icons/beachball/svg/svg.js
var import_dist9 = __toESM(require_dist(), 1);
var SVG_NS = "http://www.w3.org/2000/svg";
function svg(type) {
  return document.createElementNS(SVG_NS, type);
}

// node_modules/@polkadot/ui-shared/icons/beachball/svg/circle.js
function circle(r3, cx, cy) {
  const elem = svg("circle");
  elem.setAttributeNS("", "cx", `${cx}`);
  elem.setAttributeNS("", "cy", `${cy}`);
  elem.setAttributeNS("", "r", `${r3}`);
  return elem;
}

// node_modules/@polkadot/ui-shared/icons/beachball/shape/circle.js
function circle2(seeder2, fill, diameter, count) {
  const center = diameter / 2;
  const angle = seeder2() * 360;
  const radius = (SHAPE_COUNT - count) / SHAPE_COUNT * (diameter / 2) + diameter / 8 * seeder2();
  const offset = diameter / 4 * (seeder2() + (count + 1) / SHAPE_COUNT);
  const cx = offset * Math.sin(angle) + center;
  const cy = offset * Math.cos(angle) + center;
  const svg2 = circle(radius, cx, cy);
  svg2.setAttributeNS("", "fill", fill);
  return svg2;
}

// node_modules/@polkadot/ui-shared/icons/beachball/svg/element.js
var import_dist12 = __toESM(require_dist(), 1);
function element(size, type = "svg", x3 = 0, y3 = 0) {
  const elem = svg(type);
  elem.setAttributeNS("", "x", `${x3}`);
  elem.setAttributeNS("", "y", `${y3}`);
  elem.setAttributeNS("", "width", `${size}`);
  elem.setAttributeNS("", "height", `${size}`);
  return elem;
}

// node_modules/@polkadot/ui-shared/icons/beachball/colors.js
var import_dist14 = __toESM(require_dist(), 1);

// node_modules/colord/index.mjs
var import_dist13 = __toESM(require_dist(), 1);
var r = { grad: 0.9, turn: 360, rad: 360 / (2 * Math.PI) };
var t = function(r3) {
  return "string" == typeof r3 ? r3.length > 0 : "number" == typeof r3;
};
var n = function(r3, t3, n3) {
  return void 0 === t3 && (t3 = 0), void 0 === n3 && (n3 = Math.pow(10, t3)), Math.round(n3 * r3) / n3 + 0;
};
var e = function(r3, t3, n3) {
  return void 0 === t3 && (t3 = 0), void 0 === n3 && (n3 = 1), r3 > n3 ? n3 : r3 > t3 ? r3 : t3;
};
var u = function(r3) {
  return (r3 = isFinite(r3) ? r3 % 360 : 0) > 0 ? r3 : r3 + 360;
};
var a = function(r3) {
  return { r: e(r3.r, 0, 255), g: e(r3.g, 0, 255), b: e(r3.b, 0, 255), a: e(r3.a) };
};
var o = function(r3) {
  return { r: n(r3.r), g: n(r3.g), b: n(r3.b), a: n(r3.a, 3) };
};
var i = /^#([0-9a-f]{3,8})$/i;
var s = function(r3) {
  var t3 = r3.toString(16);
  return t3.length < 2 ? "0" + t3 : t3;
};
var h = function(r3) {
  var t3 = r3.r, n3 = r3.g, e3 = r3.b, u3 = r3.a, a3 = Math.max(t3, n3, e3), o3 = a3 - Math.min(t3, n3, e3), i3 = o3 ? a3 === t3 ? (n3 - e3) / o3 : a3 === n3 ? 2 + (e3 - t3) / o3 : 4 + (t3 - n3) / o3 : 0;
  return { h: 60 * (i3 < 0 ? i3 + 6 : i3), s: a3 ? o3 / a3 * 100 : 0, v: a3 / 255 * 100, a: u3 };
};
var b = function(r3) {
  var t3 = r3.h, n3 = r3.s, e3 = r3.v, u3 = r3.a;
  t3 = t3 / 360 * 6, n3 /= 100, e3 /= 100;
  var a3 = Math.floor(t3), o3 = e3 * (1 - n3), i3 = e3 * (1 - (t3 - a3) * n3), s3 = e3 * (1 - (1 - t3 + a3) * n3), h2 = a3 % 6;
  return { r: 255 * [e3, i3, o3, o3, s3, e3][h2], g: 255 * [s3, e3, e3, i3, o3, o3][h2], b: 255 * [o3, o3, s3, e3, e3, i3][h2], a: u3 };
};
var g = function(r3) {
  return { h: u(r3.h), s: e(r3.s, 0, 100), l: e(r3.l, 0, 100), a: e(r3.a) };
};
var d = function(r3) {
  return { h: n(r3.h), s: n(r3.s), l: n(r3.l), a: n(r3.a, 3) };
};
var f2 = function(r3) {
  return b((n3 = (t3 = r3).s, { h: t3.h, s: (n3 *= ((e3 = t3.l) < 50 ? e3 : 100 - e3) / 100) > 0 ? 2 * n3 / (e3 + n3) * 100 : 0, v: e3 + n3, a: t3.a }));
  var t3, n3, e3;
};
var c = function(r3) {
  return { h: (t3 = h(r3)).h, s: (u3 = (200 - (n3 = t3.s)) * (e3 = t3.v) / 100) > 0 && u3 < 200 ? n3 * e3 / 100 / (u3 <= 100 ? u3 : 200 - u3) * 100 : 0, l: u3 / 2, a: t3.a };
  var t3, n3, e3, u3;
};
var l = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
var p = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
var v = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
var m = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
var y = { string: [[function(r3) {
  var t3 = i.exec(r3);
  return t3 ? (r3 = t3[1]).length <= 4 ? { r: parseInt(r3[0] + r3[0], 16), g: parseInt(r3[1] + r3[1], 16), b: parseInt(r3[2] + r3[2], 16), a: 4 === r3.length ? n(parseInt(r3[3] + r3[3], 16) / 255, 2) : 1 } : 6 === r3.length || 8 === r3.length ? { r: parseInt(r3.substr(0, 2), 16), g: parseInt(r3.substr(2, 2), 16), b: parseInt(r3.substr(4, 2), 16), a: 8 === r3.length ? n(parseInt(r3.substr(6, 2), 16) / 255, 2) : 1 } : null : null;
}, "hex"], [function(r3) {
  var t3 = v.exec(r3) || m.exec(r3);
  return t3 ? t3[2] !== t3[4] || t3[4] !== t3[6] ? null : a({ r: Number(t3[1]) / (t3[2] ? 100 / 255 : 1), g: Number(t3[3]) / (t3[4] ? 100 / 255 : 1), b: Number(t3[5]) / (t3[6] ? 100 / 255 : 1), a: void 0 === t3[7] ? 1 : Number(t3[7]) / (t3[8] ? 100 : 1) }) : null;
}, "rgb"], [function(t3) {
  var n3 = l.exec(t3) || p.exec(t3);
  if (!n3)
    return null;
  var e3, u3, a3 = g({ h: (e3 = n3[1], u3 = n3[2], void 0 === u3 && (u3 = "deg"), Number(e3) * (r[u3] || 1)), s: Number(n3[3]), l: Number(n3[4]), a: void 0 === n3[5] ? 1 : Number(n3[5]) / (n3[6] ? 100 : 1) });
  return f2(a3);
}, "hsl"]], object: [[function(r3) {
  var n3 = r3.r, e3 = r3.g, u3 = r3.b, o3 = r3.a, i3 = void 0 === o3 ? 1 : o3;
  return t(n3) && t(e3) && t(u3) ? a({ r: Number(n3), g: Number(e3), b: Number(u3), a: Number(i3) }) : null;
}, "rgb"], [function(r3) {
  var n3 = r3.h, e3 = r3.s, u3 = r3.l, a3 = r3.a, o3 = void 0 === a3 ? 1 : a3;
  if (!t(n3) || !t(e3) || !t(u3))
    return null;
  var i3 = g({ h: Number(n3), s: Number(e3), l: Number(u3), a: Number(o3) });
  return f2(i3);
}, "hsl"], [function(r3) {
  var n3 = r3.h, a3 = r3.s, o3 = r3.v, i3 = r3.a, s3 = void 0 === i3 ? 1 : i3;
  if (!t(n3) || !t(a3) || !t(o3))
    return null;
  var h2 = function(r4) {
    return { h: u(r4.h), s: e(r4.s, 0, 100), v: e(r4.v, 0, 100), a: e(r4.a) };
  }({ h: Number(n3), s: Number(a3), v: Number(o3), a: Number(s3) });
  return b(h2);
}, "hsv"]] };
var N = function(r3, t3) {
  for (var n3 = 0; n3 < t3.length; n3++) {
    var e3 = t3[n3][0](r3);
    if (e3)
      return [e3, t3[n3][1]];
  }
  return [null, void 0];
};
var x = function(r3) {
  return "string" == typeof r3 ? N(r3.trim(), y.string) : "object" == typeof r3 && null !== r3 ? N(r3, y.object) : [null, void 0];
};
var M = function(r3, t3) {
  var n3 = c(r3);
  return { h: n3.h, s: e(n3.s + 100 * t3, 0, 100), l: n3.l, a: n3.a };
};
var H = function(r3) {
  return (299 * r3.r + 587 * r3.g + 114 * r3.b) / 1e3 / 255;
};
var $ = function(r3, t3) {
  var n3 = c(r3);
  return { h: n3.h, s: n3.s, l: e(n3.l + 100 * t3, 0, 100), a: n3.a };
};
var j2 = function() {
  function r3(r4) {
    this.parsed = x(r4)[0], this.rgba = this.parsed || { r: 0, g: 0, b: 0, a: 1 };
  }
  return r3.prototype.isValid = function() {
    return null !== this.parsed;
  }, r3.prototype.brightness = function() {
    return n(H(this.rgba), 2);
  }, r3.prototype.isDark = function() {
    return H(this.rgba) < 0.5;
  }, r3.prototype.isLight = function() {
    return H(this.rgba) >= 0.5;
  }, r3.prototype.toHex = function() {
    return r4 = o(this.rgba), t3 = r4.r, e3 = r4.g, u3 = r4.b, i3 = (a3 = r4.a) < 1 ? s(n(255 * a3)) : "", "#" + s(t3) + s(e3) + s(u3) + i3;
    var r4, t3, e3, u3, a3, i3;
  }, r3.prototype.toRgb = function() {
    return o(this.rgba);
  }, r3.prototype.toRgbString = function() {
    return r4 = o(this.rgba), t3 = r4.r, n3 = r4.g, e3 = r4.b, (u3 = r4.a) < 1 ? "rgba(" + t3 + ", " + n3 + ", " + e3 + ", " + u3 + ")" : "rgb(" + t3 + ", " + n3 + ", " + e3 + ")";
    var r4, t3, n3, e3, u3;
  }, r3.prototype.toHsl = function() {
    return d(c(this.rgba));
  }, r3.prototype.toHslString = function() {
    return r4 = d(c(this.rgba)), t3 = r4.h, n3 = r4.s, e3 = r4.l, (u3 = r4.a) < 1 ? "hsla(" + t3 + ", " + n3 + "%, " + e3 + "%, " + u3 + ")" : "hsl(" + t3 + ", " + n3 + "%, " + e3 + "%)";
    var r4, t3, n3, e3, u3;
  }, r3.prototype.toHsv = function() {
    return r4 = h(this.rgba), { h: n(r4.h), s: n(r4.s), v: n(r4.v), a: n(r4.a, 3) };
    var r4;
  }, r3.prototype.invert = function() {
    return w({ r: 255 - (r4 = this.rgba).r, g: 255 - r4.g, b: 255 - r4.b, a: r4.a });
    var r4;
  }, r3.prototype.saturate = function(r4) {
    return void 0 === r4 && (r4 = 0.1), w(M(this.rgba, r4));
  }, r3.prototype.desaturate = function(r4) {
    return void 0 === r4 && (r4 = 0.1), w(M(this.rgba, -r4));
  }, r3.prototype.grayscale = function() {
    return w(M(this.rgba, -1));
  }, r3.prototype.lighten = function(r4) {
    return void 0 === r4 && (r4 = 0.1), w($(this.rgba, r4));
  }, r3.prototype.darken = function(r4) {
    return void 0 === r4 && (r4 = 0.1), w($(this.rgba, -r4));
  }, r3.prototype.rotate = function(r4) {
    return void 0 === r4 && (r4 = 15), this.hue(this.hue() + r4);
  }, r3.prototype.alpha = function(r4) {
    return "number" == typeof r4 ? w({ r: (t3 = this.rgba).r, g: t3.g, b: t3.b, a: r4 }) : n(this.rgba.a, 3);
    var t3;
  }, r3.prototype.hue = function(r4) {
    var t3 = c(this.rgba);
    return "number" == typeof r4 ? w({ h: r4, s: t3.s, l: t3.l, a: t3.a }) : n(t3.h);
  }, r3.prototype.isEqual = function(r4) {
    return this.toHex() === w(r4).toHex();
  }, r3;
}();
var w = function(r3) {
  return r3 instanceof j2 ? r3 : new j2(r3);
};

// node_modules/@polkadot/ui-shared/icons/beachball/colors.js
var WOBBLE = 30;
function colors(seeder2) {
  const amount = seeder2() * WOBBLE - WOBBLE / 2;
  const all = COLORS.map((hex) => w(hex).rotate(amount));
  return (alpha = 1) => {
    const index = Math.floor(all.length * seeder2());
    return all.splice(index, 1)[0].alpha(alpha).toHslString();
  };
}

// node_modules/@polkadot/ui-shared/icons/beachball/container.js
var import_dist15 = __toESM(require_dist(), 1);
function container(diameter, background = "white", className = "", _style = {}) {
  const element2 = document.createElement("div");
  const style = Object.assign({
    background,
    borderRadius: `${diameter / 2}px`,
    display: "inline-block",
    height: `${diameter}px`,
    margin: "0px",
    overflow: "hidden",
    padding: "0px",
    width: `${diameter}px`
  }, _style);
  element2.className = className;
  element2.style.background = background;
  Object.keys(style).forEach((key) => {
    element2.style[key] = style[key];
  });
  return element2;
}

// node_modules/@polkadot/ui-shared/icons/beachball/seeder.js
var import_dist16 = __toESM(require_dist(), 1);
var DIVISOR = 256 * 256;
function seeder(_seed = new Uint8Array(32)) {
  const seed = isU8a(_seed) ? _seed : stringToU8a(_seed);
  let index = seed[Math.floor(seed.length / 2)] % seed.length - 1;
  const next = () => {
    index += 1;
    if (index === seed.length) {
      index = 0;
    }
    return seed[index];
  };
  return () => {
    return (next() * 256 + next()) / DIVISOR;
  };
}

// node_modules/@polkadot/ui-shared/icons/beachball/index.js
function beachballIcon(seed, { size = 256 }, className = "", style) {
  const seeder2 = seeder(seed);
  const colorGen = colors(seeder2);
  const outer = container(size, "white", className, style);
  const container2 = container(size, colorGen());
  const svg2 = element(size);
  outer.appendChild(container2);
  container2.appendChild(svg2);
  for (let count = 0; count < SHAPE_COUNT; count++) {
    const fill = colorGen();
    const shape = circle2(seeder2, fill, size, count);
    svg2.appendChild(shape);
  }
  return outer;
}

// node_modules/@polkadot/ui-shared/icons/polkadot.js
var import_dist18 = __toESM(require_dist(), 1);
var S = 64;
var C = S / 2;
var Z = S / 64 * 5;
var SCHEMES = [
  /* target  */
  { colors: [0, 28, 0, 0, 28, 0, 0, 28, 0, 0, 28, 0, 0, 28, 0, 0, 28, 0, 1], freq: 1 },
  /* cube    */
  { colors: [0, 1, 3, 2, 4, 3, 0, 1, 3, 2, 4, 3, 0, 1, 3, 2, 4, 3, 5], freq: 20 },
  /* quazar  */
  { colors: [1, 2, 3, 1, 2, 4, 5, 5, 4, 1, 2, 3, 1, 2, 4, 5, 5, 4, 0], freq: 16 },
  /* flower  */
  { colors: [0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 3], freq: 32 },
  /* cyclic  */
  { colors: [0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 6], freq: 32 },
  /* vmirror */
  { colors: [0, 1, 2, 3, 4, 5, 3, 4, 2, 0, 1, 6, 7, 8, 9, 7, 8, 6, 10], freq: 128 },
  /* hmirror */
  { colors: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 8, 6, 7, 5, 3, 4, 2, 11], freq: 128 }
];
var SCHEMES_TOTAL = SCHEMES.map((s3) => s3.freq).reduce((a3, b3) => a3 + b3);
var OUTER_CIRCLE = {
  cx: C,
  cy: C,
  fill: "#eee",
  r: C
};
var zeroHash = new Uint8Array();
function getRotation(isSixPoint) {
  const r3 = isSixPoint ? C / 8 * 5 : C / 4 * 3;
  const rroot3o2 = r3 * Math.sqrt(3) / 2;
  const ro2 = r3 / 2;
  const rroot3o4 = r3 * Math.sqrt(3) / 4;
  const ro4 = r3 / 4;
  const r3o4 = r3 * 3 / 4;
  return { r: r3, r3o4, ro2, ro4, rroot3o2, rroot3o4 };
}
function getCircleXY(isSixPoint = false) {
  const { r: r3, r3o4, ro2, ro4, rroot3o2, rroot3o4 } = getRotation(isSixPoint);
  return [
    [C, C - r3],
    [C, C - ro2],
    [C - rroot3o4, C - r3o4],
    [C - rroot3o2, C - ro2],
    [C - rroot3o4, C - ro4],
    [C - rroot3o2, C],
    [C - rroot3o2, C + ro2],
    [C - rroot3o4, C + ro4],
    [C - rroot3o4, C + r3o4],
    [C, C + r3],
    [C, C + ro2],
    [C + rroot3o4, C + r3o4],
    [C + rroot3o2, C + ro2],
    [C + rroot3o4, C + ro4],
    [C + rroot3o2, C],
    [C + rroot3o2, C - ro2],
    [C + rroot3o4, C - ro4],
    [C + rroot3o4, C - r3o4],
    [C, C]
  ];
}
function findScheme(d3) {
  let cum = 0;
  const schema = SCHEMES.find((schema2) => {
    cum += schema2.freq;
    return d3 < cum;
  });
  if (!schema) {
    throw new Error("Unable to find schema");
  }
  return schema;
}
function addressToId(address) {
  if (!zeroHash.length) {
    zeroHash = blake2AsU8a(new Uint8Array(32), 512);
  }
  return blake2AsU8a(decodeAddress(address), 512).map((x3, i3) => (x3 + 256 - zeroHash[i3]) % 256);
}
function getColors(address) {
  const id = addressToId(address);
  const d3 = Math.floor((id[30] + id[31] * 256) % SCHEMES_TOTAL);
  const rot = id[28] % 6 * 3;
  const sat = Math.floor(id[29] * 70 / 256 + 26) % 80 + 30;
  const scheme = findScheme(d3);
  const palette = Array.from(id).map((x3, i3) => {
    const b3 = (x3 + i3 % 28 * 58) % 256;
    if (b3 === 0) {
      return "#444";
    } else if (b3 === 255) {
      return "transparent";
    }
    const h2 = Math.floor(b3 % 64 * 360 / 64);
    const l3 = [53, 15, 35, 75][Math.floor(b3 / 64)];
    return `hsl(${h2}, ${sat}%, ${l3}%)`;
  });
  return scheme.colors.map((_2, i3) => palette[scheme.colors[i3 < 18 ? (i3 + rot) % 18 : 18]]);
}
function polkadotIcon(address, { isAlternative }) {
  const xy = getCircleXY(isAlternative);
  let colors2;
  try {
    colors2 = getColors(address);
  } catch {
    colors2 = new Array(xy.length).fill("#ddd");
  }
  return [OUTER_CIRCLE].concat(xy.map(([cx, cy], index) => ({
    cx,
    cy,
    fill: colors2[index],
    r: Z
  })));
}

// node_modules/@polkadot/react-identicon/icons/Beachball.js
function Identicon({ address, className = "", size, style }) {
  const updateElem = (0, import_react.useCallback)((node) => {
    node && node.appendChild(beachballIcon(address, { isAlternative: false, size }));
  }, [address, size]);
  return (0, import_jsx_runtime.jsx)("div", { className, ref: updateElem, style });
}
var Beachball = import_react.default.memo(Identicon);

// node_modules/@polkadot/react-identicon/icons/Empty.js
var import_dist23 = __toESM(require_dist(), 1);
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var import_react2 = __toESM(require_react(), 1);
function Identicon2({ className = "", size, style }) {
  return (0, import_jsx_runtime2.jsx)("svg", { className, height: size, style, viewBox: "0 0 64 64", width: size });
}
var Empty = import_react2.default.memo(Identicon2);

// node_modules/@polkadot/react-identicon/icons/Ethereum.js
var import_dist29 = __toESM(require_dist(), 1);
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var import_ethereum_blockies_base64 = __toESM(require_main(), 1);
var import_react4 = __toESM(require_react(), 1);

// node_modules/styled-components/dist/styled-components.browser.esm.js
var import_dist28 = __toESM(require_dist());
var import_react_is = __toESM(require_react_is());
var import_react3 = __toESM(require_react());
var import_shallowequal = __toESM(require_shallowequal());

// node_modules/@emotion/stylis/dist/stylis.browser.esm.js
var import_dist24 = __toESM(require_dist());
function stylis_min(W2) {
  function M3(d3, c3, e3, h2, a3) {
    for (var m3 = 0, b3 = 0, v3 = 0, n3 = 0, q2, g3, x3 = 0, K2 = 0, k2, u3 = k2 = q2 = 0, l3 = 0, r3 = 0, I2 = 0, t3 = 0, B3 = e3.length, J2 = B3 - 1, y3, f3 = "", p2 = "", F3 = "", G3 = "", C3; l3 < B3; ) {
      g3 = e3.charCodeAt(l3);
      l3 === J2 && 0 !== b3 + n3 + v3 + m3 && (0 !== b3 && (g3 = 47 === b3 ? 10 : 47), n3 = v3 = m3 = 0, B3++, J2++);
      if (0 === b3 + n3 + v3 + m3) {
        if (l3 === J2 && (0 < r3 && (f3 = f3.replace(N3, "")), 0 < f3.trim().length)) {
          switch (g3) {
            case 32:
            case 9:
            case 59:
            case 13:
            case 10:
              break;
            default:
              f3 += e3.charAt(l3);
          }
          g3 = 59;
        }
        switch (g3) {
          case 123:
            f3 = f3.trim();
            q2 = f3.charCodeAt(0);
            k2 = 1;
            for (t3 = ++l3; l3 < B3; ) {
              switch (g3 = e3.charCodeAt(l3)) {
                case 123:
                  k2++;
                  break;
                case 125:
                  k2--;
                  break;
                case 47:
                  switch (g3 = e3.charCodeAt(l3 + 1)) {
                    case 42:
                    case 47:
                      a: {
                        for (u3 = l3 + 1; u3 < J2; ++u3) {
                          switch (e3.charCodeAt(u3)) {
                            case 47:
                              if (42 === g3 && 42 === e3.charCodeAt(u3 - 1) && l3 + 2 !== u3) {
                                l3 = u3 + 1;
                                break a;
                              }
                              break;
                            case 10:
                              if (47 === g3) {
                                l3 = u3 + 1;
                                break a;
                              }
                          }
                        }
                        l3 = u3;
                      }
                  }
                  break;
                case 91:
                  g3++;
                case 40:
                  g3++;
                case 34:
                case 39:
                  for (; l3++ < J2 && e3.charCodeAt(l3) !== g3; ) {
                  }
              }
              if (0 === k2)
                break;
              l3++;
            }
            k2 = e3.substring(t3, l3);
            0 === q2 && (q2 = (f3 = f3.replace(ca, "").trim()).charCodeAt(0));
            switch (q2) {
              case 64:
                0 < r3 && (f3 = f3.replace(N3, ""));
                g3 = f3.charCodeAt(1);
                switch (g3) {
                  case 100:
                  case 109:
                  case 115:
                  case 45:
                    r3 = c3;
                    break;
                  default:
                    r3 = O2;
                }
                k2 = M3(c3, r3, k2, g3, a3 + 1);
                t3 = k2.length;
                0 < A && (r3 = X2(O2, f3, I2), C3 = H3(3, k2, r3, c3, D2, z2, t3, g3, a3, h2), f3 = r3.join(""), void 0 !== C3 && 0 === (t3 = (k2 = C3.trim()).length) && (g3 = 0, k2 = ""));
                if (0 < t3)
                  switch (g3) {
                    case 115:
                      f3 = f3.replace(da, ea);
                    case 100:
                    case 109:
                    case 45:
                      k2 = f3 + "{" + k2 + "}";
                      break;
                    case 107:
                      f3 = f3.replace(fa, "$1 $2");
                      k2 = f3 + "{" + k2 + "}";
                      k2 = 1 === w3 || 2 === w3 && L2("@" + k2, 3) ? "@-webkit-" + k2 + "@" + k2 : "@" + k2;
                      break;
                    default:
                      k2 = f3 + k2, 112 === h2 && (k2 = (p2 += k2, ""));
                  }
                else
                  k2 = "";
                break;
              default:
                k2 = M3(c3, X2(c3, f3, I2), k2, h2, a3 + 1);
            }
            F3 += k2;
            k2 = I2 = r3 = u3 = q2 = 0;
            f3 = "";
            g3 = e3.charCodeAt(++l3);
            break;
          case 125:
          case 59:
            f3 = (0 < r3 ? f3.replace(N3, "") : f3).trim();
            if (1 < (t3 = f3.length))
              switch (0 === u3 && (q2 = f3.charCodeAt(0), 45 === q2 || 96 < q2 && 123 > q2) && (t3 = (f3 = f3.replace(" ", ":")).length), 0 < A && void 0 !== (C3 = H3(1, f3, c3, d3, D2, z2, p2.length, h2, a3, h2)) && 0 === (t3 = (f3 = C3.trim()).length) && (f3 = "\0\0"), q2 = f3.charCodeAt(0), g3 = f3.charCodeAt(1), q2) {
                case 0:
                  break;
                case 64:
                  if (105 === g3 || 99 === g3) {
                    G3 += f3 + e3.charAt(l3);
                    break;
                  }
                default:
                  58 !== f3.charCodeAt(t3 - 1) && (p2 += P(f3, q2, g3, f3.charCodeAt(2)));
              }
            I2 = r3 = u3 = q2 = 0;
            f3 = "";
            g3 = e3.charCodeAt(++l3);
        }
      }
      switch (g3) {
        case 13:
        case 10:
          47 === b3 ? b3 = 0 : 0 === 1 + q2 && 107 !== h2 && 0 < f3.length && (r3 = 1, f3 += "\0");
          0 < A * Y2 && H3(0, f3, c3, d3, D2, z2, p2.length, h2, a3, h2);
          z2 = 1;
          D2++;
          break;
        case 59:
        case 125:
          if (0 === b3 + n3 + v3 + m3) {
            z2++;
            break;
          }
        default:
          z2++;
          y3 = e3.charAt(l3);
          switch (g3) {
            case 9:
            case 32:
              if (0 === n3 + m3 + b3)
                switch (x3) {
                  case 44:
                  case 58:
                  case 9:
                  case 32:
                    y3 = "";
                    break;
                  default:
                    32 !== g3 && (y3 = " ");
                }
              break;
            case 0:
              y3 = "\\0";
              break;
            case 12:
              y3 = "\\f";
              break;
            case 11:
              y3 = "\\v";
              break;
            case 38:
              0 === n3 + b3 + m3 && (r3 = I2 = 1, y3 = "\f" + y3);
              break;
            case 108:
              if (0 === n3 + b3 + m3 + E2 && 0 < u3)
                switch (l3 - u3) {
                  case 2:
                    112 === x3 && 58 === e3.charCodeAt(l3 - 3) && (E2 = x3);
                  case 8:
                    111 === K2 && (E2 = K2);
                }
              break;
            case 58:
              0 === n3 + b3 + m3 && (u3 = l3);
              break;
            case 44:
              0 === b3 + v3 + n3 + m3 && (r3 = 1, y3 += "\r");
              break;
            case 34:
            case 39:
              0 === b3 && (n3 = n3 === g3 ? 0 : 0 === n3 ? g3 : n3);
              break;
            case 91:
              0 === n3 + b3 + v3 && m3++;
              break;
            case 93:
              0 === n3 + b3 + v3 && m3--;
              break;
            case 41:
              0 === n3 + b3 + m3 && v3--;
              break;
            case 40:
              if (0 === n3 + b3 + m3) {
                if (0 === q2)
                  switch (2 * x3 + 3 * K2) {
                    case 533:
                      break;
                    default:
                      q2 = 1;
                  }
                v3++;
              }
              break;
            case 64:
              0 === b3 + v3 + n3 + m3 + u3 + k2 && (k2 = 1);
              break;
            case 42:
            case 47:
              if (!(0 < n3 + m3 + v3))
                switch (b3) {
                  case 0:
                    switch (2 * g3 + 3 * e3.charCodeAt(l3 + 1)) {
                      case 235:
                        b3 = 47;
                        break;
                      case 220:
                        t3 = l3, b3 = 42;
                    }
                    break;
                  case 42:
                    47 === g3 && 42 === x3 && t3 + 2 !== l3 && (33 === e3.charCodeAt(t3 + 2) && (p2 += e3.substring(t3, l3 + 1)), y3 = "", b3 = 0);
                }
          }
          0 === b3 && (f3 += y3);
      }
      K2 = x3;
      x3 = g3;
      l3++;
    }
    t3 = p2.length;
    if (0 < t3) {
      r3 = c3;
      if (0 < A && (C3 = H3(2, p2, r3, d3, D2, z2, t3, h2, a3, h2), void 0 !== C3 && 0 === (p2 = C3).length))
        return G3 + p2 + F3;
      p2 = r3.join(",") + "{" + p2 + "}";
      if (0 !== w3 * E2) {
        2 !== w3 || L2(p2, 2) || (E2 = 0);
        switch (E2) {
          case 111:
            p2 = p2.replace(ha, ":-moz-$1") + p2;
            break;
          case 112:
            p2 = p2.replace(Q2, "::-webkit-input-$1") + p2.replace(Q2, "::-moz-$1") + p2.replace(Q2, ":-ms-input-$1") + p2;
        }
        E2 = 0;
      }
    }
    return G3 + p2 + F3;
  }
  function X2(d3, c3, e3) {
    var h2 = c3.trim().split(ia);
    c3 = h2;
    var a3 = h2.length, m3 = d3.length;
    switch (m3) {
      case 0:
      case 1:
        var b3 = 0;
        for (d3 = 0 === m3 ? "" : d3[0] + " "; b3 < a3; ++b3) {
          c3[b3] = Z3(d3, c3[b3], e3).trim();
        }
        break;
      default:
        var v3 = b3 = 0;
        for (c3 = []; b3 < a3; ++b3) {
          for (var n3 = 0; n3 < m3; ++n3) {
            c3[v3++] = Z3(d3[n3] + " ", h2[b3], e3).trim();
          }
        }
    }
    return c3;
  }
  function Z3(d3, c3, e3) {
    var h2 = c3.charCodeAt(0);
    33 > h2 && (h2 = (c3 = c3.trim()).charCodeAt(0));
    switch (h2) {
      case 38:
        return c3.replace(F2, "$1" + d3.trim());
      case 58:
        return d3.trim() + c3.replace(F2, "$1" + d3.trim());
      default:
        if (0 < 1 * e3 && 0 < c3.indexOf("\f"))
          return c3.replace(F2, (58 === d3.charCodeAt(0) ? "" : "$1") + d3.trim());
    }
    return d3 + c3;
  }
  function P(d3, c3, e3, h2) {
    var a3 = d3 + ";", m3 = 2 * c3 + 3 * e3 + 4 * h2;
    if (944 === m3) {
      d3 = a3.indexOf(":", 9) + 1;
      var b3 = a3.substring(d3, a3.length - 1).trim();
      b3 = a3.substring(0, d3).trim() + b3 + ";";
      return 1 === w3 || 2 === w3 && L2(b3, 1) ? "-webkit-" + b3 + b3 : b3;
    }
    if (0 === w3 || 2 === w3 && !L2(a3, 1))
      return a3;
    switch (m3) {
      case 1015:
        return 97 === a3.charCodeAt(10) ? "-webkit-" + a3 + a3 : a3;
      case 951:
        return 116 === a3.charCodeAt(3) ? "-webkit-" + a3 + a3 : a3;
      case 963:
        return 110 === a3.charCodeAt(5) ? "-webkit-" + a3 + a3 : a3;
      case 1009:
        if (100 !== a3.charCodeAt(4))
          break;
      case 969:
      case 942:
        return "-webkit-" + a3 + a3;
      case 978:
        return "-webkit-" + a3 + "-moz-" + a3 + a3;
      case 1019:
      case 983:
        return "-webkit-" + a3 + "-moz-" + a3 + "-ms-" + a3 + a3;
      case 883:
        if (45 === a3.charCodeAt(8))
          return "-webkit-" + a3 + a3;
        if (0 < a3.indexOf("image-set(", 11))
          return a3.replace(ja, "$1-webkit-$2") + a3;
        break;
      case 932:
        if (45 === a3.charCodeAt(4))
          switch (a3.charCodeAt(5)) {
            case 103:
              return "-webkit-box-" + a3.replace("-grow", "") + "-webkit-" + a3 + "-ms-" + a3.replace("grow", "positive") + a3;
            case 115:
              return "-webkit-" + a3 + "-ms-" + a3.replace("shrink", "negative") + a3;
            case 98:
              return "-webkit-" + a3 + "-ms-" + a3.replace("basis", "preferred-size") + a3;
          }
        return "-webkit-" + a3 + "-ms-" + a3 + a3;
      case 964:
        return "-webkit-" + a3 + "-ms-flex-" + a3 + a3;
      case 1023:
        if (99 !== a3.charCodeAt(8))
          break;
        b3 = a3.substring(a3.indexOf(":", 15)).replace("flex-", "").replace("space-between", "justify");
        return "-webkit-box-pack" + b3 + "-webkit-" + a3 + "-ms-flex-pack" + b3 + a3;
      case 1005:
        return ka.test(a3) ? a3.replace(aa, ":-webkit-") + a3.replace(aa, ":-moz-") + a3 : a3;
      case 1e3:
        b3 = a3.substring(13).trim();
        c3 = b3.indexOf("-") + 1;
        switch (b3.charCodeAt(0) + b3.charCodeAt(c3)) {
          case 226:
            b3 = a3.replace(G2, "tb");
            break;
          case 232:
            b3 = a3.replace(G2, "tb-rl");
            break;
          case 220:
            b3 = a3.replace(G2, "lr");
            break;
          default:
            return a3;
        }
        return "-webkit-" + a3 + "-ms-" + b3 + a3;
      case 1017:
        if (-1 === a3.indexOf("sticky", 9))
          break;
      case 975:
        c3 = (a3 = d3).length - 10;
        b3 = (33 === a3.charCodeAt(c3) ? a3.substring(0, c3) : a3).substring(d3.indexOf(":", 7) + 1).trim();
        switch (m3 = b3.charCodeAt(0) + (b3.charCodeAt(7) | 0)) {
          case 203:
            if (111 > b3.charCodeAt(8))
              break;
          case 115:
            a3 = a3.replace(b3, "-webkit-" + b3) + ";" + a3;
            break;
          case 207:
          case 102:
            a3 = a3.replace(b3, "-webkit-" + (102 < m3 ? "inline-" : "") + "box") + ";" + a3.replace(b3, "-webkit-" + b3) + ";" + a3.replace(b3, "-ms-" + b3 + "box") + ";" + a3;
        }
        return a3 + ";";
      case 938:
        if (45 === a3.charCodeAt(5))
          switch (a3.charCodeAt(6)) {
            case 105:
              return b3 = a3.replace("-items", ""), "-webkit-" + a3 + "-webkit-box-" + b3 + "-ms-flex-" + b3 + a3;
            case 115:
              return "-webkit-" + a3 + "-ms-flex-item-" + a3.replace(ba, "") + a3;
            default:
              return "-webkit-" + a3 + "-ms-flex-line-pack" + a3.replace("align-content", "").replace(ba, "") + a3;
          }
        break;
      case 973:
      case 989:
        if (45 !== a3.charCodeAt(3) || 122 === a3.charCodeAt(4))
          break;
      case 931:
      case 953:
        if (true === la.test(d3))
          return 115 === (b3 = d3.substring(d3.indexOf(":") + 1)).charCodeAt(0) ? P(d3.replace("stretch", "fill-available"), c3, e3, h2).replace(":fill-available", ":stretch") : a3.replace(b3, "-webkit-" + b3) + a3.replace(b3, "-moz-" + b3.replace("fill-", "")) + a3;
        break;
      case 962:
        if (a3 = "-webkit-" + a3 + (102 === a3.charCodeAt(5) ? "-ms-" + a3 : "") + a3, 211 === e3 + h2 && 105 === a3.charCodeAt(13) && 0 < a3.indexOf("transform", 10))
          return a3.substring(0, a3.indexOf(";", 27) + 1).replace(ma, "$1-webkit-$2") + a3;
    }
    return a3;
  }
  function L2(d3, c3) {
    var e3 = d3.indexOf(1 === c3 ? ":" : "{"), h2 = d3.substring(0, 3 !== c3 ? e3 : 10);
    e3 = d3.substring(e3 + 1, d3.length - 1);
    return R2(2 !== c3 ? h2 : h2.replace(na, "$1"), e3, c3);
  }
  function ea(d3, c3) {
    var e3 = P(c3, c3.charCodeAt(0), c3.charCodeAt(1), c3.charCodeAt(2));
    return e3 !== c3 + ";" ? e3.replace(oa, " or ($1)").substring(4) : "(" + c3 + ")";
  }
  function H3(d3, c3, e3, h2, a3, m3, b3, v3, n3, q2) {
    for (var g3 = 0, x3 = c3, w4; g3 < A; ++g3) {
      switch (w4 = S3[g3].call(B2, d3, x3, e3, h2, a3, m3, b3, v3, n3, q2)) {
        case void 0:
        case false:
        case true:
        case null:
          break;
        default:
          x3 = w4;
      }
    }
    if (x3 !== c3)
      return x3;
  }
  function T2(d3) {
    switch (d3) {
      case void 0:
      case null:
        A = S3.length = 0;
        break;
      default:
        if ("function" === typeof d3)
          S3[A++] = d3;
        else if ("object" === typeof d3)
          for (var c3 = 0, e3 = d3.length; c3 < e3; ++c3) {
            T2(d3[c3]);
          }
        else
          Y2 = !!d3 | 0;
    }
    return T2;
  }
  function U2(d3) {
    d3 = d3.prefix;
    void 0 !== d3 && (R2 = null, d3 ? "function" !== typeof d3 ? w3 = 1 : (w3 = 2, R2 = d3) : w3 = 0);
    return U2;
  }
  function B2(d3, c3) {
    var e3 = d3;
    33 > e3.charCodeAt(0) && (e3 = e3.trim());
    V2 = e3;
    e3 = [V2];
    if (0 < A) {
      var h2 = H3(-1, c3, e3, e3, D2, z2, 0, 0, 0, 0);
      void 0 !== h2 && "string" === typeof h2 && (c3 = h2);
    }
    var a3 = M3(O2, e3, c3, 0, 0);
    0 < A && (h2 = H3(-2, a3, e3, e3, D2, z2, a3.length, 0, 0, 0), void 0 !== h2 && (a3 = h2));
    V2 = "";
    E2 = 0;
    z2 = D2 = 1;
    return a3;
  }
  var ca = /^\0+/g, N3 = /[\0\r\f]/g, aa = /: */g, ka = /zoo|gra/, ma = /([,: ])(transform)/g, ia = /,\r+?/g, F2 = /([\t\r\n ])*\f?&/g, fa = /@(k\w+)\s*(\S*)\s*/, Q2 = /::(place)/g, ha = /:(read-only)/g, G2 = /[svh]\w+-[tblr]{2}/, da = /\(\s*(.*)\s*\)/g, oa = /([\s\S]*?);/g, ba = /-self|flex-/g, na = /[^]*?(:[rp][el]a[\w-]+)[^]*/, la = /stretch|:\s*\w+\-(?:conte|avail)/, ja = /([^-])(image-set\()/, z2 = 1, D2 = 1, E2 = 0, w3 = 1, O2 = [], S3 = [], A = 0, R2 = null, Y2 = 0, V2 = "";
  B2.use = T2;
  B2.set = U2;
  void 0 !== W2 && U2(W2);
  return B2;
}
var stylis_browser_esm_default = stylis_min;

// node_modules/@emotion/unitless/dist/unitless.browser.esm.js
var import_dist25 = __toESM(require_dist());
var unitlessKeys = {
  animationIterationCount: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};
var unitless_browser_esm_default = unitlessKeys;

// node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.esm.js
var import_dist27 = __toESM(require_dist());

// node_modules/@emotion/memoize/dist/emotion-memoize.esm.js
var import_dist26 = __toESM(require_dist());
function memoize(fn) {
  var cache = /* @__PURE__ */ Object.create(null);
  return function(arg) {
    if (cache[arg] === void 0)
      cache[arg] = fn(arg);
    return cache[arg];
  };
}

// node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.esm.js
var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
var isPropValid = memoize(
  function(prop) {
    return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
  }
  /* Z+1 */
);

// node_modules/styled-components/dist/styled-components.browser.esm.js
var import_hoist_non_react_statics = __toESM(require_hoist_non_react_statics_cjs());
function y2() {
  return (y2 = Object.assign || function(e3) {
    for (var t3 = 1; t3 < arguments.length; t3++) {
      var n3 = arguments[t3];
      for (var r3 in n3)
        Object.prototype.hasOwnProperty.call(n3, r3) && (e3[r3] = n3[r3]);
    }
    return e3;
  }).apply(this, arguments);
}
var v2 = function(e3, t3) {
  for (var n3 = [e3[0]], r3 = 0, o3 = t3.length; r3 < o3; r3 += 1)
    n3.push(t3[r3], e3[r3 + 1]);
  return n3;
};
var g2 = function(t3) {
  return null !== t3 && "object" == typeof t3 && "[object Object]" === (t3.toString ? t3.toString() : Object.prototype.toString.call(t3)) && !(0, import_react_is.typeOf)(t3);
};
var S2 = Object.freeze([]);
var w2 = Object.freeze({});
function E(e3) {
  return "function" == typeof e3;
}
function b2(e3) {
  return "production" !== process.env.NODE_ENV && "string" == typeof e3 && e3 || e3.displayName || e3.name || "Component";
}
function _(e3) {
  return e3 && "string" == typeof e3.styledComponentId;
}
var N2 = "undefined" != typeof process && void 0 !== process.env && (process.env.REACT_APP_SC_ATTR || process.env.SC_ATTR) || "data-styled";
var C2 = "undefined" != typeof window && "HTMLElement" in window;
var I = Boolean("boolean" == typeof SC_DISABLE_SPEEDY ? SC_DISABLE_SPEEDY : "undefined" != typeof process && void 0 !== process.env && (void 0 !== process.env.REACT_APP_SC_DISABLE_SPEEDY && "" !== process.env.REACT_APP_SC_DISABLE_SPEEDY ? "false" !== process.env.REACT_APP_SC_DISABLE_SPEEDY && process.env.REACT_APP_SC_DISABLE_SPEEDY : void 0 !== process.env.SC_DISABLE_SPEEDY && "" !== process.env.SC_DISABLE_SPEEDY ? "false" !== process.env.SC_DISABLE_SPEEDY && process.env.SC_DISABLE_SPEEDY : "production" !== process.env.NODE_ENV));
var O = "production" !== process.env.NODE_ENV ? { 1: "Cannot create styled-component for component: %s.\n\n", 2: "Can't collect styles once you've consumed a `ServerStyleSheet`'s styles! `ServerStyleSheet` is a one off instance for each server-side render cycle.\n\n- Are you trying to reuse it across renders?\n- Are you accidentally calling collectStyles twice?\n\n", 3: "Streaming SSR is only supported in a Node.js environment; Please do not try to call this method in the browser.\n\n", 4: "The `StyleSheetManager` expects a valid target or sheet prop!\n\n- Does this error occur on the client and is your target falsy?\n- Does this error occur on the server and is the sheet falsy?\n\n", 5: "The clone method cannot be used on the client!\n\n- Are you running in a client-like environment on the server?\n- Are you trying to run SSR on the client?\n\n", 6: "Trying to insert a new style tag, but the given Node is unmounted!\n\n- Are you using a custom target that isn't mounted?\n- Does your document not have a valid head element?\n- Have you accidentally removed a style tag manually?\n\n", 7: 'ThemeProvider: Please return an object from your "theme" prop function, e.g.\n\n```js\ntheme={() => ({})}\n```\n\n', 8: 'ThemeProvider: Please make your "theme" prop an object.\n\n', 9: "Missing document `<head>`\n\n", 10: "Cannot find a StyleSheet instance. Usually this happens if there are multiple copies of styled-components loaded at once. Check out this issue for how to troubleshoot and fix the common cases where this situation can happen: https://github.com/styled-components/styled-components/issues/1941#issuecomment-417862021\n\n", 11: "_This error was replaced with a dev-time warning, it will be deleted for v4 final._ [createGlobalStyle] received children which will not be rendered. Please use the component without passing children elements.\n\n", 12: "It seems you are interpolating a keyframe declaration (%s) into an untagged string. This was supported in styled-components v3, but is not longer supported in v4 as keyframes are now injected on-demand. Please wrap your string in the css\\`\\` helper which ensures the styles are injected correctly. See https://www.styled-components.com/docs/api#css\n\n", 13: "%s is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details.\n\n", 14: 'ThemeProvider: "theme" prop is required.\n\n', 15: "A stylis plugin has been supplied that is not named. We need a name for each plugin to be able to prevent styling collisions between different stylis configurations within the same app. Before you pass your plugin to `<StyleSheetManager stylisPlugins={[]}>`, please make sure each plugin is uniquely-named, e.g.\n\n```js\nObject.defineProperty(importedPlugin, 'name', { value: 'some-unique-name' });\n```\n\n", 16: "Reached the limit of how many styled components may be created at group %s.\nYou may only create up to 1,073,741,824 components. If you're creating components dynamically,\nas for instance in your render method then you may be running into this limitation.\n\n", 17: "CSSStyleSheet could not be found on HTMLStyleElement.\nHas styled-components' style tag been unmounted or altered by another script?\n" } : {};
function R() {
  for (var e3 = arguments.length <= 0 ? void 0 : arguments[0], t3 = [], n3 = 1, r3 = arguments.length; n3 < r3; n3 += 1)
    t3.push(n3 < 0 || arguments.length <= n3 ? void 0 : arguments[n3]);
  return t3.forEach(function(t4) {
    e3 = e3.replace(/%[a-z]/, t4);
  }), e3;
}
function D(e3) {
  for (var t3 = arguments.length, n3 = new Array(t3 > 1 ? t3 - 1 : 0), r3 = 1; r3 < t3; r3++)
    n3[r3 - 1] = arguments[r3];
  throw "production" === process.env.NODE_ENV ? new Error("An error occurred. See https://git.io/JUIaE#" + e3 + " for more information." + (n3.length > 0 ? " Args: " + n3.join(", ") : "")) : new Error(R.apply(void 0, [O[e3]].concat(n3)).trim());
}
var j3 = function() {
  function e3(e4) {
    this.groupSizes = new Uint32Array(512), this.length = 512, this.tag = e4;
  }
  var t3 = e3.prototype;
  return t3.indexOfGroup = function(e4) {
    for (var t4 = 0, n3 = 0; n3 < e4; n3++)
      t4 += this.groupSizes[n3];
    return t4;
  }, t3.insertRules = function(e4, t4) {
    if (e4 >= this.groupSizes.length) {
      for (var n3 = this.groupSizes, r3 = n3.length, o3 = r3; e4 >= o3; )
        (o3 <<= 1) < 0 && D(16, "" + e4);
      this.groupSizes = new Uint32Array(o3), this.groupSizes.set(n3), this.length = o3;
      for (var s3 = r3; s3 < o3; s3++)
        this.groupSizes[s3] = 0;
    }
    for (var i3 = this.indexOfGroup(e4 + 1), a3 = 0, c3 = t4.length; a3 < c3; a3++)
      this.tag.insertRule(i3, t4[a3]) && (this.groupSizes[e4]++, i3++);
  }, t3.clearGroup = function(e4) {
    if (e4 < this.length) {
      var t4 = this.groupSizes[e4], n3 = this.indexOfGroup(e4), r3 = n3 + t4;
      this.groupSizes[e4] = 0;
      for (var o3 = n3; o3 < r3; o3++)
        this.tag.deleteRule(n3);
    }
  }, t3.getGroup = function(e4) {
    var t4 = "";
    if (e4 >= this.length || 0 === this.groupSizes[e4])
      return t4;
    for (var n3 = this.groupSizes[e4], r3 = this.indexOfGroup(e4), o3 = r3 + n3, s3 = r3; s3 < o3; s3++)
      t4 += this.tag.getRule(s3) + "/*!sc*/\n";
    return t4;
  }, e3;
}();
var T = /* @__PURE__ */ new Map();
var x2 = /* @__PURE__ */ new Map();
var k = 1;
var V = function(e3) {
  if (T.has(e3))
    return T.get(e3);
  for (; x2.has(k); )
    k++;
  var t3 = k++;
  return "production" !== process.env.NODE_ENV && ((0 | t3) < 0 || t3 > 1 << 30) && D(16, "" + t3), T.set(e3, t3), x2.set(t3, e3), t3;
};
var B = function(e3) {
  return x2.get(e3);
};
var z = function(e3, t3) {
  t3 >= k && (k = t3 + 1), T.set(e3, t3), x2.set(t3, e3);
};
var M2 = "style[" + N2 + '][data-styled-version="5.3.11"]';
var G = new RegExp("^" + N2 + '\\.g(\\d+)\\[id="([\\w\\d-]+)"\\].*?"([^"]*)');
var L = function(e3, t3, n3) {
  for (var r3, o3 = n3.split(","), s3 = 0, i3 = o3.length; s3 < i3; s3++)
    (r3 = o3[s3]) && e3.registerName(t3, r3);
};
var F = function(e3, t3) {
  for (var n3 = (t3.textContent || "").split("/*!sc*/\n"), r3 = [], o3 = 0, s3 = n3.length; o3 < s3; o3++) {
    var i3 = n3[o3].trim();
    if (i3) {
      var a3 = i3.match(G);
      if (a3) {
        var c3 = 0 | parseInt(a3[1], 10), u3 = a3[2];
        0 !== c3 && (z(u3, c3), L(e3, u3, a3[3]), e3.getTag().insertRules(c3, r3)), r3.length = 0;
      } else
        r3.push(i3);
    }
  }
};
var Y = function() {
  return "undefined" != typeof __webpack_nonce__ ? __webpack_nonce__ : null;
};
var q = function(e3) {
  var t3 = document.head, n3 = e3 || t3, r3 = document.createElement("style"), o3 = function(e4) {
    for (var t4 = e4.childNodes, n4 = t4.length; n4 >= 0; n4--) {
      var r4 = t4[n4];
      if (r4 && 1 === r4.nodeType && r4.hasAttribute(N2))
        return r4;
    }
  }(n3), s3 = void 0 !== o3 ? o3.nextSibling : null;
  r3.setAttribute(N2, "active"), r3.setAttribute("data-styled-version", "5.3.11");
  var i3 = Y();
  return i3 && r3.setAttribute("nonce", i3), n3.insertBefore(r3, s3), r3;
};
var H2 = function() {
  function e3(e4) {
    var t4 = this.element = q(e4);
    t4.appendChild(document.createTextNode("")), this.sheet = function(e5) {
      if (e5.sheet)
        return e5.sheet;
      for (var t5 = document.styleSheets, n3 = 0, r3 = t5.length; n3 < r3; n3++) {
        var o3 = t5[n3];
        if (o3.ownerNode === e5)
          return o3;
      }
      D(17);
    }(t4), this.length = 0;
  }
  var t3 = e3.prototype;
  return t3.insertRule = function(e4, t4) {
    try {
      return this.sheet.insertRule(t4, e4), this.length++, true;
    } catch (e5) {
      return false;
    }
  }, t3.deleteRule = function(e4) {
    this.sheet.deleteRule(e4), this.length--;
  }, t3.getRule = function(e4) {
    var t4 = this.sheet.cssRules[e4];
    return void 0 !== t4 && "string" == typeof t4.cssText ? t4.cssText : "";
  }, e3;
}();
var $2 = function() {
  function e3(e4) {
    var t4 = this.element = q(e4);
    this.nodes = t4.childNodes, this.length = 0;
  }
  var t3 = e3.prototype;
  return t3.insertRule = function(e4, t4) {
    if (e4 <= this.length && e4 >= 0) {
      var n3 = document.createTextNode(t4), r3 = this.nodes[e4];
      return this.element.insertBefore(n3, r3 || null), this.length++, true;
    }
    return false;
  }, t3.deleteRule = function(e4) {
    this.element.removeChild(this.nodes[e4]), this.length--;
  }, t3.getRule = function(e4) {
    return e4 < this.length ? this.nodes[e4].textContent : "";
  }, e3;
}();
var W = function() {
  function e3(e4) {
    this.rules = [], this.length = 0;
  }
  var t3 = e3.prototype;
  return t3.insertRule = function(e4, t4) {
    return e4 <= this.length && (this.rules.splice(e4, 0, t4), this.length++, true);
  }, t3.deleteRule = function(e4) {
    this.rules.splice(e4, 1), this.length--;
  }, t3.getRule = function(e4) {
    return e4 < this.length ? this.rules[e4] : "";
  }, e3;
}();
var U = C2;
var J = { isServer: !C2, useCSSOMInjection: !I };
var X = function() {
  function e3(e4, t4, n3) {
    void 0 === e4 && (e4 = w2), void 0 === t4 && (t4 = {}), this.options = y2({}, J, {}, e4), this.gs = t4, this.names = new Map(n3), this.server = !!e4.isServer, !this.server && C2 && U && (U = false, function(e5) {
      for (var t5 = document.querySelectorAll(M2), n4 = 0, r3 = t5.length; n4 < r3; n4++) {
        var o3 = t5[n4];
        o3 && "active" !== o3.getAttribute(N2) && (F(e5, o3), o3.parentNode && o3.parentNode.removeChild(o3));
      }
    }(this));
  }
  e3.registerId = function(e4) {
    return V(e4);
  };
  var t3 = e3.prototype;
  return t3.reconstructWithOptions = function(t4, n3) {
    return void 0 === n3 && (n3 = true), new e3(y2({}, this.options, {}, t4), this.gs, n3 && this.names || void 0);
  }, t3.allocateGSInstance = function(e4) {
    return this.gs[e4] = (this.gs[e4] || 0) + 1;
  }, t3.getTag = function() {
    return this.tag || (this.tag = (n3 = (t4 = this.options).isServer, r3 = t4.useCSSOMInjection, o3 = t4.target, e4 = n3 ? new W(o3) : r3 ? new H2(o3) : new $2(o3), new j3(e4)));
    var e4, t4, n3, r3, o3;
  }, t3.hasNameForId = function(e4, t4) {
    return this.names.has(e4) && this.names.get(e4).has(t4);
  }, t3.registerName = function(e4, t4) {
    if (V(e4), this.names.has(e4))
      this.names.get(e4).add(t4);
    else {
      var n3 = /* @__PURE__ */ new Set();
      n3.add(t4), this.names.set(e4, n3);
    }
  }, t3.insertRules = function(e4, t4, n3) {
    this.registerName(e4, t4), this.getTag().insertRules(V(e4), n3);
  }, t3.clearNames = function(e4) {
    this.names.has(e4) && this.names.get(e4).clear();
  }, t3.clearRules = function(e4) {
    this.getTag().clearGroup(V(e4)), this.clearNames(e4);
  }, t3.clearTag = function() {
    this.tag = void 0;
  }, t3.toString = function() {
    return function(e4) {
      for (var t4 = e4.getTag(), n3 = t4.length, r3 = "", o3 = 0; o3 < n3; o3++) {
        var s3 = B(o3);
        if (void 0 !== s3) {
          var i3 = e4.names.get(s3), a3 = t4.getGroup(o3);
          if (i3 && a3 && i3.size) {
            var c3 = N2 + ".g" + o3 + '[id="' + s3 + '"]', u3 = "";
            void 0 !== i3 && i3.forEach(function(e5) {
              e5.length > 0 && (u3 += e5 + ",");
            }), r3 += "" + a3 + c3 + '{content:"' + u3 + '"}/*!sc*/\n';
          }
        }
      }
      return r3;
    }(this);
  }, e3;
}();
var Z2 = /(a)(d)/gi;
var K = function(e3) {
  return String.fromCharCode(e3 + (e3 > 25 ? 39 : 97));
};
function Q(e3) {
  var t3, n3 = "";
  for (t3 = Math.abs(e3); t3 > 52; t3 = t3 / 52 | 0)
    n3 = K(t3 % 52) + n3;
  return (K(t3 % 52) + n3).replace(Z2, "$1-$2");
}
var ee = function(e3, t3) {
  for (var n3 = t3.length; n3; )
    e3 = 33 * e3 ^ t3.charCodeAt(--n3);
  return e3;
};
var te = function(e3) {
  return ee(5381, e3);
};
function ne(e3) {
  for (var t3 = 0; t3 < e3.length; t3 += 1) {
    var n3 = e3[t3];
    if (E(n3) && !_(n3))
      return false;
  }
  return true;
}
var re = te("5.3.11");
var oe = function() {
  function e3(e4, t3, n3) {
    this.rules = e4, this.staticRulesId = "", this.isStatic = "production" === process.env.NODE_ENV && (void 0 === n3 || n3.isStatic) && ne(e4), this.componentId = t3, this.baseHash = ee(re, t3), this.baseStyle = n3, X.registerId(t3);
  }
  return e3.prototype.generateAndInjectStyles = function(e4, t3, n3) {
    var r3 = this.componentId, o3 = [];
    if (this.baseStyle && o3.push(this.baseStyle.generateAndInjectStyles(e4, t3, n3)), this.isStatic && !n3.hash)
      if (this.staticRulesId && t3.hasNameForId(r3, this.staticRulesId))
        o3.push(this.staticRulesId);
      else {
        var s3 = _e(this.rules, e4, t3, n3).join(""), i3 = Q(ee(this.baseHash, s3) >>> 0);
        if (!t3.hasNameForId(r3, i3)) {
          var a3 = n3(s3, "." + i3, void 0, r3);
          t3.insertRules(r3, i3, a3);
        }
        o3.push(i3), this.staticRulesId = i3;
      }
    else {
      for (var c3 = this.rules.length, u3 = ee(this.baseHash, n3.hash), l3 = "", d3 = 0; d3 < c3; d3++) {
        var h2 = this.rules[d3];
        if ("string" == typeof h2)
          l3 += h2, "production" !== process.env.NODE_ENV && (u3 = ee(u3, h2 + d3));
        else if (h2) {
          var p2 = _e(h2, e4, t3, n3), f3 = Array.isArray(p2) ? p2.join("") : p2;
          u3 = ee(u3, f3 + d3), l3 += f3;
        }
      }
      if (l3) {
        var m3 = Q(u3 >>> 0);
        if (!t3.hasNameForId(r3, m3)) {
          var y3 = n3(l3, "." + m3, void 0, r3);
          t3.insertRules(r3, m3, y3);
        }
        o3.push(m3);
      }
    }
    return o3.join(" ");
  }, e3;
}();
var se = /^\s*\/\/.*$/gm;
var ie = [":", "[", ".", "#"];
function ae(e3) {
  var t3, n3, r3, o3, s3 = void 0 === e3 ? w2 : e3, i3 = s3.options, a3 = void 0 === i3 ? w2 : i3, c3 = s3.plugins, u3 = void 0 === c3 ? S2 : c3, l3 = new stylis_browser_esm_default(a3), d3 = [], p2 = /* @__PURE__ */ function(e4) {
    function t4(t5) {
      if (t5)
        try {
          e4(t5 + "}");
        } catch (e5) {
        }
    }
    return function(n4, r4, o4, s4, i4, a4, c4, u4, l4, d4) {
      switch (n4) {
        case 1:
          if (0 === l4 && 64 === r4.charCodeAt(0))
            return e4(r4 + ";"), "";
          break;
        case 2:
          if (0 === u4)
            return r4 + "/*|*/";
          break;
        case 3:
          switch (u4) {
            case 102:
            case 112:
              return e4(o4[0] + r4), "";
            default:
              return r4 + (0 === d4 ? "/*|*/" : "");
          }
        case -2:
          r4.split("/*|*/}").forEach(t4);
      }
    };
  }(function(e4) {
    d3.push(e4);
  }), f3 = function(e4, r4, s4) {
    return 0 === r4 && -1 !== ie.indexOf(s4[n3.length]) || s4.match(o3) ? e4 : "." + t3;
  };
  function m3(e4, s4, i4, a4) {
    void 0 === a4 && (a4 = "&");
    var c4 = e4.replace(se, ""), u4 = s4 && i4 ? i4 + " " + s4 + " { " + c4 + " }" : c4;
    return t3 = a4, n3 = s4, r3 = new RegExp("\\" + n3 + "\\b", "g"), o3 = new RegExp("(\\" + n3 + "\\b){2,}"), l3(i4 || !s4 ? "" : s4, u4);
  }
  return l3.use([].concat(u3, [function(e4, t4, o4) {
    2 === e4 && o4.length && o4[0].lastIndexOf(n3) > 0 && (o4[0] = o4[0].replace(r3, f3));
  }, p2, function(e4) {
    if (-2 === e4) {
      var t4 = d3;
      return d3 = [], t4;
    }
  }])), m3.hash = u3.length ? u3.reduce(function(e4, t4) {
    return t4.name || D(15), ee(e4, t4.name);
  }, 5381).toString() : "", m3;
}
var ce = import_react3.default.createContext();
var ue = ce.Consumer;
var le = import_react3.default.createContext();
var de = (le.Consumer, new X());
var he = ae();
function pe() {
  return (0, import_react3.useContext)(ce) || de;
}
function fe() {
  return (0, import_react3.useContext)(le) || he;
}
function me(e3) {
  var t3 = (0, import_react3.useState)(e3.stylisPlugins), n3 = t3[0], s3 = t3[1], c3 = pe(), u3 = (0, import_react3.useMemo)(function() {
    var t4 = c3;
    return e3.sheet ? t4 = e3.sheet : e3.target && (t4 = t4.reconstructWithOptions({ target: e3.target }, false)), e3.disableCSSOMInjection && (t4 = t4.reconstructWithOptions({ useCSSOMInjection: false })), t4;
  }, [e3.disableCSSOMInjection, e3.sheet, e3.target]), l3 = (0, import_react3.useMemo)(function() {
    return ae({ options: { prefix: !e3.disableVendorPrefixes }, plugins: n3 });
  }, [e3.disableVendorPrefixes, n3]);
  return (0, import_react3.useEffect)(function() {
    (0, import_shallowequal.default)(n3, e3.stylisPlugins) || s3(e3.stylisPlugins);
  }, [e3.stylisPlugins]), import_react3.default.createElement(ce.Provider, { value: u3 }, import_react3.default.createElement(le.Provider, { value: l3 }, "production" !== process.env.NODE_ENV ? import_react3.default.Children.only(e3.children) : e3.children));
}
var ye = function() {
  function e3(e4, t3) {
    var n3 = this;
    this.inject = function(e5, t4) {
      void 0 === t4 && (t4 = he);
      var r3 = n3.name + t4.hash;
      e5.hasNameForId(n3.id, r3) || e5.insertRules(n3.id, r3, t4(n3.rules, r3, "@keyframes"));
    }, this.toString = function() {
      return D(12, String(n3.name));
    }, this.name = e4, this.id = "sc-keyframes-" + e4, this.rules = t3;
  }
  return e3.prototype.getName = function(e4) {
    return void 0 === e4 && (e4 = he), this.name + e4.hash;
  }, e3;
}();
var ve = /([A-Z])/;
var ge = /([A-Z])/g;
var Se = /^ms-/;
var we = function(e3) {
  return "-" + e3.toLowerCase();
};
function Ee(e3) {
  return ve.test(e3) ? e3.replace(ge, we).replace(Se, "-ms-") : e3;
}
var be = function(e3) {
  return null == e3 || false === e3 || "" === e3;
};
function _e(e3, n3, r3, o3) {
  if (Array.isArray(e3)) {
    for (var s3, i3 = [], a3 = 0, c3 = e3.length; a3 < c3; a3 += 1)
      "" !== (s3 = _e(e3[a3], n3, r3, o3)) && (Array.isArray(s3) ? i3.push.apply(i3, s3) : i3.push(s3));
    return i3;
  }
  if (be(e3))
    return "";
  if (_(e3))
    return "." + e3.styledComponentId;
  if (E(e3)) {
    if ("function" != typeof (l3 = e3) || l3.prototype && l3.prototype.isReactComponent || !n3)
      return e3;
    var u3 = e3(n3);
    return "production" !== process.env.NODE_ENV && (0, import_react_is.isElement)(u3) && console.warn(b2(e3) + " is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details."), _e(u3, n3, r3, o3);
  }
  var l3;
  return e3 instanceof ye ? r3 ? (e3.inject(r3, o3), e3.getName(o3)) : e3 : g2(e3) ? function e4(t3, n4) {
    var r4, o4, s4 = [];
    for (var i4 in t3)
      t3.hasOwnProperty(i4) && !be(t3[i4]) && (Array.isArray(t3[i4]) && t3[i4].isCss || E(t3[i4]) ? s4.push(Ee(i4) + ":", t3[i4], ";") : g2(t3[i4]) ? s4.push.apply(s4, e4(t3[i4], i4)) : s4.push(Ee(i4) + ": " + (r4 = i4, null == (o4 = t3[i4]) || "boolean" == typeof o4 || "" === o4 ? "" : "number" != typeof o4 || 0 === o4 || r4 in unitless_browser_esm_default || r4.startsWith("--") ? String(o4).trim() : o4 + "px") + ";"));
    return n4 ? [n4 + " {"].concat(s4, ["}"]) : s4;
  }(e3) : e3.toString();
}
var Ne = function(e3) {
  return Array.isArray(e3) && (e3.isCss = true), e3;
};
function Ae(e3) {
  for (var t3 = arguments.length, n3 = new Array(t3 > 1 ? t3 - 1 : 0), r3 = 1; r3 < t3; r3++)
    n3[r3 - 1] = arguments[r3];
  return E(e3) || g2(e3) ? Ne(_e(v2(S2, [e3].concat(n3)))) : 0 === n3.length && 1 === e3.length && "string" == typeof e3[0] ? e3 : Ne(_e(v2(e3, n3)));
}
var Ce = /invalid hook call/i;
var Ie = /* @__PURE__ */ new Set();
var Pe = function(e3, t3) {
  if ("production" !== process.env.NODE_ENV) {
    var n3 = "The component " + e3 + (t3 ? ' with the id of "' + t3 + '"' : "") + " has been created dynamically.\nYou may see this warning because you've called styled inside another component.\nTo resolve this only create new StyledComponents outside of any render method and function component.", r3 = console.error;
    try {
      var o3 = true;
      console.error = function(e4) {
        if (Ce.test(e4))
          o3 = false, Ie.delete(n3);
        else {
          for (var t4 = arguments.length, s3 = new Array(t4 > 1 ? t4 - 1 : 0), i3 = 1; i3 < t4; i3++)
            s3[i3 - 1] = arguments[i3];
          r3.apply(void 0, [e4].concat(s3));
        }
      }, (0, import_react3.useRef)(), o3 && !Ie.has(n3) && (console.warn(n3), Ie.add(n3));
    } catch (e4) {
      Ce.test(e4.message) && Ie.delete(n3);
    } finally {
      console.error = r3;
    }
  }
};
var Oe = function(e3, t3, n3) {
  return void 0 === n3 && (n3 = w2), e3.theme !== n3.theme && e3.theme || t3 || n3.theme;
};
var Re = /[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g;
var De = /(^-|-$)/g;
function je(e3) {
  return e3.replace(Re, "-").replace(De, "");
}
var Te = function(e3) {
  return Q(te(e3) >>> 0);
};
function xe(e3) {
  return "string" == typeof e3 && ("production" === process.env.NODE_ENV || e3.charAt(0) === e3.charAt(0).toLowerCase());
}
var ke = function(e3) {
  return "function" == typeof e3 || "object" == typeof e3 && null !== e3 && !Array.isArray(e3);
};
var Ve = function(e3) {
  return "__proto__" !== e3 && "constructor" !== e3 && "prototype" !== e3;
};
function Be(e3, t3, n3) {
  var r3 = e3[n3];
  ke(t3) && ke(r3) ? ze(r3, t3) : e3[n3] = t3;
}
function ze(e3) {
  for (var t3 = arguments.length, n3 = new Array(t3 > 1 ? t3 - 1 : 0), r3 = 1; r3 < t3; r3++)
    n3[r3 - 1] = arguments[r3];
  for (var o3 = 0, s3 = n3; o3 < s3.length; o3++) {
    var i3 = s3[o3];
    if (ke(i3))
      for (var a3 in i3)
        Ve(a3) && Be(e3, i3[a3], a3);
  }
  return e3;
}
var Me = import_react3.default.createContext();
var Ge = Me.Consumer;
var Fe = {};
function Ye(e3, t3, n3) {
  var o3 = _(e3), i3 = !xe(e3), a3 = t3.attrs, c3 = void 0 === a3 ? S2 : a3, l3 = t3.componentId, d3 = void 0 === l3 ? function(e4, t4) {
    var n4 = "string" != typeof e4 ? "sc" : je(e4);
    Fe[n4] = (Fe[n4] || 0) + 1;
    var r3 = n4 + "-" + Te("5.3.11" + n4 + Fe[n4]);
    return t4 ? t4 + "-" + r3 : r3;
  }(t3.displayName, t3.parentComponentId) : l3, h2 = t3.displayName, p2 = void 0 === h2 ? function(e4) {
    return xe(e4) ? "styled." + e4 : "Styled(" + b2(e4) + ")";
  }(e3) : h2, v3 = t3.displayName && t3.componentId ? je(t3.displayName) + "-" + t3.componentId : t3.componentId || d3, g3 = o3 && e3.attrs ? Array.prototype.concat(e3.attrs, c3).filter(Boolean) : c3, N3 = t3.shouldForwardProp;
  o3 && e3.shouldForwardProp && (N3 = t3.shouldForwardProp ? function(n4, r3, o4) {
    return e3.shouldForwardProp(n4, r3, o4) && t3.shouldForwardProp(n4, r3, o4);
  } : e3.shouldForwardProp);
  var A, C3 = new oe(n3, v3, o3 ? e3.componentStyle : void 0), I2 = C3.isStatic && 0 === c3.length, P = function(e4, t4) {
    return function(e5, t5, n4, r3) {
      var o4 = e5.attrs, i4 = e5.componentStyle, a4 = e5.defaultProps, c4 = e5.foldedComponentIds, l4 = e5.shouldForwardProp, d4 = e5.styledComponentId, h3 = e5.target, p3 = function(e6, t6, n5) {
        void 0 === e6 && (e6 = w2);
        var r4 = y2({}, t6, { theme: e6 }), o5 = {};
        return n5.forEach(function(e7) {
          var t7, n6, s3, i5 = e7;
          for (t7 in E(i5) && (i5 = i5(r4)), i5)
            r4[t7] = o5[t7] = "className" === t7 ? (n6 = o5[t7], s3 = i5[t7], n6 && s3 ? n6 + " " + s3 : n6 || s3) : i5[t7];
        }), [r4, o5];
      }(Oe(t5, (0, import_react3.useContext)(Me), a4) || w2, t5, o4), m3 = p3[0], v4 = p3[1], g4 = function(e6, t6, n5, r4) {
        var o5 = pe(), s3 = fe(), i5 = t6 ? e6.generateAndInjectStyles(w2, o5, s3) : e6.generateAndInjectStyles(n5, o5, s3);
        return "production" !== process.env.NODE_ENV && !t6 && r4 && r4(i5), i5;
      }(i4, r3, m3, "production" !== process.env.NODE_ENV ? e5.warnTooManyClasses : void 0), S3 = n4, b3 = v4.$as || t5.$as || v4.as || t5.as || h3, _2 = xe(b3), N4 = v4 !== t5 ? y2({}, t5, {}, v4) : t5, A2 = {};
      for (var C4 in N4)
        "$" !== C4[0] && "as" !== C4 && ("forwardedAs" === C4 ? A2.as = N4[C4] : (l4 ? l4(C4, isPropValid, b3) : !_2 || isPropValid(C4)) && (A2[C4] = N4[C4]));
      return t5.style && v4.style !== t5.style && (A2.style = y2({}, t5.style, {}, v4.style)), A2.className = Array.prototype.concat(c4, d4, g4 !== d4 ? g4 : null, t5.className, v4.className).filter(Boolean).join(" "), A2.ref = S3, (0, import_react3.createElement)(b3, A2);
    }(A, e4, t4, I2);
  };
  return P.displayName = p2, (A = import_react3.default.forwardRef(P)).attrs = g3, A.componentStyle = C3, A.displayName = p2, A.shouldForwardProp = N3, A.foldedComponentIds = o3 ? Array.prototype.concat(e3.foldedComponentIds, e3.styledComponentId) : S2, A.styledComponentId = v3, A.target = o3 ? e3.target : e3, A.withComponent = function(e4) {
    var r3 = t3.componentId, o4 = function(e5, t4) {
      if (null == e5)
        return {};
      var n4, r4, o5 = {}, s4 = Object.keys(e5);
      for (r4 = 0; r4 < s4.length; r4++)
        n4 = s4[r4], t4.indexOf(n4) >= 0 || (o5[n4] = e5[n4]);
      return o5;
    }(t3, ["componentId"]), s3 = r3 && r3 + "-" + (xe(e4) ? e4 : je(b2(e4)));
    return Ye(e4, y2({}, o4, { attrs: g3, componentId: s3 }), n3);
  }, Object.defineProperty(A, "defaultProps", { get: function() {
    return this._foldedDefaultProps;
  }, set: function(t4) {
    this._foldedDefaultProps = o3 ? ze({}, e3.defaultProps, t4) : t4;
  } }), "production" !== process.env.NODE_ENV && (Pe(p2, v3), A.warnTooManyClasses = /* @__PURE__ */ function(e4, t4) {
    var n4 = {}, r3 = false;
    return function(o4) {
      if (!r3 && (n4[o4] = true, Object.keys(n4).length >= 200)) {
        var s3 = t4 ? ' with the id of "' + t4 + '"' : "";
        console.warn("Over 200 classes were generated for component " + e4 + s3 + ".\nConsider using the attrs method, together with a style object for frequently changed styles.\nExample:\n  const Component = styled.div.attrs(props => ({\n    style: {\n      background: props.background,\n    },\n  }))`width: 100%;`\n\n  <Component />"), r3 = true, n4 = {};
      }
    };
  }(p2, v3)), Object.defineProperty(A, "toString", { value: function() {
    return "." + A.styledComponentId;
  } }), i3 && (0, import_hoist_non_react_statics.default)(A, e3, { attrs: true, componentStyle: true, displayName: true, foldedComponentIds: true, shouldForwardProp: true, styledComponentId: true, target: true, withComponent: true }), A;
}
var qe = function(e3) {
  return function e4(t3, r3, o3) {
    if (void 0 === o3 && (o3 = w2), !(0, import_react_is.isValidElementType)(r3))
      return D(1, String(r3));
    var s3 = function() {
      return t3(r3, o3, Ae.apply(void 0, arguments));
    };
    return s3.withConfig = function(n3) {
      return e4(t3, r3, y2({}, o3, {}, n3));
    }, s3.attrs = function(n3) {
      return e4(t3, r3, y2({}, o3, { attrs: Array.prototype.concat(o3.attrs, n3).filter(Boolean) }));
    }, s3;
  }(Ye, e3);
};
["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "marquee", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "marker", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "textPath", "tspan"].forEach(function(e3) {
  qe[e3] = qe(e3);
});
var He = function() {
  function e3(e4, t4) {
    this.rules = e4, this.componentId = t4, this.isStatic = ne(e4), X.registerId(this.componentId + 1);
  }
  var t3 = e3.prototype;
  return t3.createStyles = function(e4, t4, n3, r3) {
    var o3 = r3(_e(this.rules, t4, n3, r3).join(""), ""), s3 = this.componentId + e4;
    n3.insertRules(s3, s3, o3);
  }, t3.removeStyles = function(e4, t4) {
    t4.clearRules(this.componentId + e4);
  }, t3.renderStyles = function(e4, t4, n3, r3) {
    e4 > 2 && X.registerId(this.componentId + e4), this.removeStyles(e4, n3), this.createStyles(e4, t4, n3, r3);
  }, e3;
}();
var Ue = function() {
  function e3() {
    var e4 = this;
    this._emitSheetCSS = function() {
      var t4 = e4.instance.toString();
      if (!t4)
        return "";
      var n3 = Y();
      return "<style " + [n3 && 'nonce="' + n3 + '"', N2 + '="true"', 'data-styled-version="5.3.11"'].filter(Boolean).join(" ") + ">" + t4 + "</style>";
    }, this.getStyleTags = function() {
      return e4.sealed ? D(2) : e4._emitSheetCSS();
    }, this.getStyleElement = function() {
      var t4;
      if (e4.sealed)
        return D(2);
      var n3 = ((t4 = {})[N2] = "", t4["data-styled-version"] = "5.3.11", t4.dangerouslySetInnerHTML = { __html: e4.instance.toString() }, t4), o3 = Y();
      return o3 && (n3.nonce = o3), [import_react3.default.createElement("style", y2({}, n3, { key: "sc-0-0" }))];
    }, this.seal = function() {
      e4.sealed = true;
    }, this.instance = new X({ isServer: true }), this.sealed = false;
  }
  var t3 = e3.prototype;
  return t3.collectStyles = function(e4) {
    return this.sealed ? D(2) : import_react3.default.createElement(me, { sheet: this.instance }, e4);
  }, t3.interleaveWithNodeStream = function(e4) {
    return D(3);
  }, e3;
}();
"production" !== process.env.NODE_ENV && "undefined" != typeof navigator && "ReactNative" === navigator.product && console.warn("It looks like you've imported 'styled-components' on React Native.\nPerhaps you're looking to import 'styled-components/native'?\nRead more about this at https://www.styled-components.com/docs/basics#react-native"), "production" !== process.env.NODE_ENV && "test" !== process.env.NODE_ENV && "undefined" != typeof window && (window["__styled-components-init__"] = window["__styled-components-init__"] || 0, 1 === window["__styled-components-init__"] && console.warn("It looks like there are several instances of 'styled-components' initialized in this application. This may cause dynamic styles to not render properly, errors during the rehydration process, a missing theme prop, and makes your application bigger without good reason.\n\nSee https://s-c.sh/2BAXzed for more info."), window["__styled-components-init__"] += 1);
var styled_components_browser_esm_default = qe;

// node_modules/@polkadot/react-identicon/icons/Ethereum.js
var styled = styled_components_browser_esm_default.styled || styled_components_browser_esm_default.default || styled_components_browser_esm_default;
function Identicon3({ address, className = "", size, style }) {
  const imgSrc = (0, import_react4.useMemo)(() => (0, import_ethereum_blockies_base64.default)(address), [address]);
  return (0, import_jsx_runtime3.jsx)(StyledImg, { className, size, src: imgSrc, style });
}
var StyledImg = styled.img(({ size }) => `
  display: block;
  height: ${size}px;
  width: ${size}px;
`);
var Ethereum = import_react4.default.memo(Identicon3);

// node_modules/@polkadot/react-identicon/icons/Jdenticon.js
var import_dist31 = __toESM(require_dist(), 1);
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);

// node_modules/jdenticon/dist/jdenticon-module.mjs
var import_dist30 = __toESM(require_dist(), 1);
function parseHex(hash, startPosition, octets) {
  return parseInt(hash.substr(startPosition, octets), 16);
}
function decToHex(v3) {
  v3 |= 0;
  return v3 < 0 ? "00" : v3 < 16 ? "0" + v3.toString(16) : v3 < 256 ? v3.toString(16) : "ff";
}
function hueToRgb(m1, m22, h2) {
  h2 = h2 < 0 ? h2 + 6 : h2 > 6 ? h2 - 6 : h2;
  return decToHex(255 * (h2 < 1 ? m1 + (m22 - m1) * h2 : h2 < 3 ? m22 : h2 < 4 ? m1 + (m22 - m1) * (4 - h2) : m1));
}
function parseColor(color) {
  if (/^#[0-9a-f]{3,8}$/i.test(color)) {
    let result;
    const colorLength = color.length;
    if (colorLength < 6) {
      const r3 = color[1], g3 = color[2], b3 = color[3], a3 = color[4] || "";
      result = "#" + r3 + r3 + g3 + g3 + b3 + b3 + a3 + a3;
    }
    if (colorLength == 7 || colorLength > 8) {
      result = color;
    }
    return result;
  }
}
function hsl(hue, saturation, lightness) {
  let result;
  if (saturation == 0) {
    const partialHex = decToHex(lightness * 255);
    result = partialHex + partialHex + partialHex;
  } else {
    const m22 = lightness <= 0.5 ? lightness * (saturation + 1) : lightness + saturation - lightness * saturation, m1 = lightness * 2 - m22;
    result = hueToRgb(m1, m22, hue * 6 + 2) + hueToRgb(m1, m22, hue * 6) + hueToRgb(m1, m22, hue * 6 - 2);
  }
  return "#" + result;
}
function correctedHsl(hue, saturation, lightness) {
  const correctors = [0.55, 0.5, 0.5, 0.46, 0.6, 0.55, 0.55], corrector = correctors[hue * 6 + 0.5 | 0];
  lightness = lightness < 0.5 ? lightness * corrector * 2 : corrector + (lightness - 0.5) * (1 - corrector) * 2;
  return hsl(hue, saturation, lightness);
}
var GLOBAL = typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : typeof global !== "undefined" ? global : {};
var CONFIG_PROPERTIES = {
  V: "jdenticon_config",
  n: "config"
};
var rootConfigurationHolder = {};
function getConfiguration(paddingOrLocalConfig, defaultPadding) {
  const configObject = typeof paddingOrLocalConfig == "object" && paddingOrLocalConfig || rootConfigurationHolder[
    CONFIG_PROPERTIES.n
    /*MODULE*/
  ] || GLOBAL[
    CONFIG_PROPERTIES.V
    /*GLOBAL*/
  ] || {}, lightnessConfig = configObject["lightness"] || {}, saturation = configObject["saturation"] || {}, colorSaturation = "color" in saturation ? saturation["color"] : saturation, grayscaleSaturation = saturation["grayscale"], backColor = configObject["backColor"], padding = configObject["padding"];
  function lightness(configName, defaultRange) {
    let range = lightnessConfig[configName];
    if (!(range && range.length > 1)) {
      range = defaultRange;
    }
    return function(value) {
      value = range[0] + value * (range[1] - range[0]);
      return value < 0 ? 0 : value > 1 ? 1 : value;
    };
  }
  function hueFunction(originalHue) {
    const hueConfig = configObject["hues"];
    let hue;
    if (hueConfig && hueConfig.length > 0) {
      hue = hueConfig[0 | 0.999 * originalHue * hueConfig.length];
    }
    return typeof hue == "number" ? (
      // A hue was specified. We need to convert the hue from
      // degrees on any turn - e.g. 746° is a perfectly valid hue -
      // to turns in the range [0, 1).
      (hue / 360 % 1 + 1) % 1
    ) : (
      // No hue configured => use original hue
      originalHue
    );
  }
  return {
    W: hueFunction,
    o: typeof colorSaturation == "number" ? colorSaturation : 0.5,
    D: typeof grayscaleSaturation == "number" ? grayscaleSaturation : 0,
    p: lightness("color", [0.4, 0.8]),
    F: lightness("grayscale", [0.3, 0.9]),
    G: parseColor(backColor),
    X: typeof paddingOrLocalConfig == "number" ? paddingOrLocalConfig : typeof padding == "number" ? padding : defaultPadding
  };
}
var Point = class {
  /**
   * @param {number} x 
   * @param {number} y 
   */
  constructor(x3, y3) {
    this.x = x3;
    this.y = y3;
  }
};
var Transform = class {
  /**
   * @param {number} x The x-coordinate of the upper left corner of the transformed rectangle.
   * @param {number} y The y-coordinate of the upper left corner of the transformed rectangle.
   * @param {number} size The size of the transformed rectangle.
   * @param {number} rotation Rotation specified as 0 = 0 rad, 1 = 0.5π rad, 2 = π rad, 3 = 1.5π rad
   */
  constructor(x3, y3, size, rotation) {
    this.q = x3;
    this.t = y3;
    this.H = size;
    this.Y = rotation;
  }
  /**
   * Transforms the specified point based on the translation and rotation specification for this Transform.
   * @param {number} x x-coordinate
   * @param {number} y y-coordinate
   * @param {number=} w The width of the transformed rectangle. If greater than 0, this will ensure the returned point is of the upper left corner of the transformed rectangle.
   * @param {number=} h The height of the transformed rectangle. If greater than 0, this will ensure the returned point is of the upper left corner of the transformed rectangle.
   */
  I(x3, y3, w3, h2) {
    const right = this.q + this.H, bottom = this.t + this.H, rotation = this.Y;
    return rotation === 1 ? new Point(right - y3 - (h2 || 0), this.t + x3) : rotation === 2 ? new Point(right - x3 - (w3 || 0), bottom - y3 - (h2 || 0)) : rotation === 3 ? new Point(this.q + y3, bottom - x3 - (w3 || 0)) : new Point(this.q + x3, this.t + y3);
  }
};
var NO_TRANSFORM = new Transform(0, 0, 0, 0);
var Graphics = class {
  /**
   * @param {Renderer} renderer 
   */
  constructor(renderer) {
    this.J = renderer;
    this.u = NO_TRANSFORM;
  }
  /**
   * Adds a polygon to the underlying renderer.
   * @param {Array<number>} points The points of the polygon clockwise on the format [ x0, y0, x1, y1, ..., xn, yn ]
   * @param {boolean=} invert Specifies if the polygon will be inverted.
   */
  g(points, invert) {
    const di = invert ? -2 : 2, transformedPoints = [];
    for (let i3 = invert ? points.length - 2 : 0; i3 < points.length && i3 >= 0; i3 += di) {
      transformedPoints.push(this.u.I(points[i3], points[i3 + 1]));
    }
    this.J.g(transformedPoints);
  }
  /**
   * Adds a polygon to the underlying renderer.
   * Source: http://stackoverflow.com/a/2173084
   * @param {number} x The x-coordinate of the upper left corner of the rectangle holding the entire ellipse.
   * @param {number} y The y-coordinate of the upper left corner of the rectangle holding the entire ellipse.
   * @param {number} size The size of the ellipse.
   * @param {boolean=} invert Specifies if the ellipse will be inverted.
   */
  h(x3, y3, size, invert) {
    const p2 = this.u.I(x3, y3, size, size);
    this.J.h(p2, size, invert);
  }
  /**
   * Adds a rectangle to the underlying renderer.
   * @param {number} x The x-coordinate of the upper left corner of the rectangle.
   * @param {number} y The y-coordinate of the upper left corner of the rectangle.
   * @param {number} w The width of the rectangle.
   * @param {number} h The height of the rectangle.
   * @param {boolean=} invert Specifies if the rectangle will be inverted.
   */
  i(x3, y3, w3, h2, invert) {
    this.g([
      x3,
      y3,
      x3 + w3,
      y3,
      x3 + w3,
      y3 + h2,
      x3,
      y3 + h2
    ], invert);
  }
  /**
   * Adds a right triangle to the underlying renderer.
   * @param {number} x The x-coordinate of the upper left corner of the rectangle holding the triangle.
   * @param {number} y The y-coordinate of the upper left corner of the rectangle holding the triangle.
   * @param {number} w The width of the triangle.
   * @param {number} h The height of the triangle.
   * @param {number} r The rotation of the triangle (clockwise). 0 = right corner of the triangle in the lower left corner of the bounding rectangle.
   * @param {boolean=} invert Specifies if the triangle will be inverted.
   */
  j(x3, y3, w3, h2, r3, invert) {
    const points = [
      x3 + w3,
      y3,
      x3 + w3,
      y3 + h2,
      x3,
      y3 + h2,
      x3,
      y3
    ];
    points.splice((r3 || 0) % 4 * 2, 2);
    this.g(points, invert);
  }
  /**
   * Adds a rhombus to the underlying renderer.
   * @param {number} x The x-coordinate of the upper left corner of the rectangle holding the rhombus.
   * @param {number} y The y-coordinate of the upper left corner of the rectangle holding the rhombus.
   * @param {number} w The width of the rhombus.
   * @param {number} h The height of the rhombus.
   * @param {boolean=} invert Specifies if the rhombus will be inverted.
   */
  K(x3, y3, w3, h2, invert) {
    this.g([
      x3 + w3 / 2,
      y3,
      x3 + w3,
      y3 + h2 / 2,
      x3 + w3 / 2,
      y3 + h2,
      x3,
      y3 + h2 / 2
    ], invert);
  }
};
function centerShape(index, g3, cell, positionIndex) {
  index = index % 14;
  let k2, m3, w3, h2, inner, outer;
  !index ? (k2 = cell * 0.42, g3.g([
    0,
    0,
    cell,
    0,
    cell,
    cell - k2 * 2,
    cell - k2,
    cell,
    0,
    cell
  ])) : index == 1 ? (w3 = 0 | cell * 0.5, h2 = 0 | cell * 0.8, g3.j(cell - w3, 0, w3, h2, 2)) : index == 2 ? (w3 = 0 | cell / 3, g3.i(w3, w3, cell - w3, cell - w3)) : index == 3 ? (inner = cell * 0.1, // Use fixed outer border widths in small icons to ensure the border is drawn
  outer = cell < 6 ? 1 : cell < 8 ? 2 : 0 | cell * 0.25, inner = inner > 1 ? 0 | inner : (
    // large icon => truncate decimals
    inner > 0.5 ? 1 : (
      // medium size icon => fixed width
      inner
    )
  ), // small icon => anti-aliased border
  g3.i(outer, outer, cell - inner - outer, cell - inner - outer)) : index == 4 ? (m3 = 0 | cell * 0.15, w3 = 0 | cell * 0.5, g3.h(cell - w3 - m3, cell - w3 - m3, w3)) : index == 5 ? (inner = cell * 0.1, outer = inner * 4, // Align edge to nearest pixel in large icons
  outer > 3 && (outer = 0 | outer), g3.i(0, 0, cell, cell), g3.g([
    outer,
    outer,
    cell - inner,
    outer,
    outer + (cell - outer - inner) / 2,
    cell - inner
  ], true)) : index == 6 ? g3.g([
    0,
    0,
    cell,
    0,
    cell,
    cell * 0.7,
    cell * 0.4,
    cell * 0.4,
    cell * 0.7,
    cell,
    0,
    cell
  ]) : index == 7 ? g3.j(cell / 2, cell / 2, cell / 2, cell / 2, 3) : index == 8 ? (g3.i(0, 0, cell, cell / 2), g3.i(0, cell / 2, cell / 2, cell / 2), g3.j(cell / 2, cell / 2, cell / 2, cell / 2, 1)) : index == 9 ? (inner = cell * 0.14, // Use fixed outer border widths in small icons to ensure the border is drawn
  outer = cell < 4 ? 1 : cell < 6 ? 2 : 0 | cell * 0.35, inner = cell < 8 ? inner : (
    // small icon => anti-aliased border
    0 | inner
  ), // large icon => truncate decimals
  g3.i(0, 0, cell, cell), g3.i(outer, outer, cell - outer - inner, cell - outer - inner, true)) : index == 10 ? (inner = cell * 0.12, outer = inner * 3, g3.i(0, 0, cell, cell), g3.h(outer, outer, cell - inner - outer, true)) : index == 11 ? g3.j(cell / 2, cell / 2, cell / 2, cell / 2, 3) : index == 12 ? (m3 = cell * 0.25, g3.i(0, 0, cell, cell), g3.K(m3, m3, cell - m3, cell - m3, true)) : (
    // 13
    !positionIndex && (m3 = cell * 0.4, w3 = cell * 1.2, g3.h(m3, m3, w3))
  );
}
function outerShape(index, g3, cell) {
  index = index % 4;
  let m3;
  !index ? g3.j(0, 0, cell, cell, 0) : index == 1 ? g3.j(0, cell / 2, cell, cell / 2, 0) : index == 2 ? g3.K(0, 0, cell, cell) : (
    // 3
    (m3 = cell / 6, g3.h(m3, m3, cell - 2 * m3))
  );
}
function colorTheme(hue, config) {
  hue = config.W(hue);
  return [
    // Dark gray
    correctedHsl(hue, config.D, config.F(0)),
    // Mid color
    correctedHsl(hue, config.o, config.p(0.5)),
    // Light gray
    correctedHsl(hue, config.D, config.F(1)),
    // Light color
    correctedHsl(hue, config.o, config.p(1)),
    // Dark color
    correctedHsl(hue, config.o, config.p(0))
  ];
}
function iconGenerator(renderer, hash, config) {
  const parsedConfig = getConfiguration(config, 0.08);
  if (parsedConfig.G) {
    renderer.m(
      parsedConfig.G
      /*backColor*/
    );
  }
  let size = renderer.k;
  const padding = 0.5 + size * parsedConfig.X | 0;
  size -= padding * 2;
  const graphics = new Graphics(renderer);
  const cell = 0 | size / 4;
  const x3 = 0 | padding + size / 2 - cell * 2;
  const y3 = 0 | padding + size / 2 - cell * 2;
  function renderShape(colorIndex, shapes, index2, rotationIndex, positions) {
    const shapeIndex = parseHex(hash, index2, 1);
    let r3 = rotationIndex ? parseHex(hash, rotationIndex, 1) : 0;
    renderer.L(availableColors[selectedColorIndexes[colorIndex]]);
    for (let i3 = 0; i3 < positions.length; i3++) {
      graphics.u = new Transform(x3 + positions[i3][0] * cell, y3 + positions[i3][1] * cell, cell, r3++ % 4);
      shapes(shapeIndex, graphics, cell, i3);
    }
    renderer.M();
  }
  const hue = parseHex(hash, -7) / 268435455, availableColors = colorTheme(hue, parsedConfig), selectedColorIndexes = [];
  let index;
  function isDuplicate(values) {
    if (values.indexOf(index) >= 0) {
      for (let i3 = 0; i3 < values.length; i3++) {
        if (selectedColorIndexes.indexOf(values[i3]) >= 0) {
          return true;
        }
      }
    }
  }
  for (let i3 = 0; i3 < 3; i3++) {
    index = parseHex(hash, 8 + i3, 1) % availableColors.length;
    if (isDuplicate([0, 4]) || // Disallow dark gray and dark color combo
    isDuplicate([2, 3])) {
      index = 1;
    }
    selectedColorIndexes.push(index);
  }
  renderShape(0, outerShape, 2, 3, [[1, 0], [2, 0], [2, 3], [1, 3], [0, 1], [3, 1], [3, 2], [0, 2]]);
  renderShape(1, outerShape, 4, 5, [[0, 0], [3, 0], [3, 3], [0, 3]]);
  renderShape(2, centerShape, 1, null, [[1, 1], [2, 1], [2, 2], [1, 2]]);
  renderer.finish();
}
function sha1(message) {
  const HASH_SIZE_HALF_BYTES = 40;
  const BLOCK_SIZE_WORDS = 16;
  var i3 = 0, f3 = 0, urlEncodedMessage = encodeURI(message) + "%80", data = [], dataSize, hashBuffer = [], a3 = 1732584193, b3 = 4023233417, c3 = ~a3, d3 = ~b3, e3 = 3285377520, hash = [a3, b3, c3, d3, e3], blockStartIndex = 0, hexHash = "";
  function rotl(value, shift) {
    return value << shift | value >>> 32 - shift;
  }
  for (; i3 < urlEncodedMessage.length; f3++) {
    data[f3 >> 2] = data[f3 >> 2] | (urlEncodedMessage[i3] == "%" ? parseInt(urlEncodedMessage.substring(i3 + 1, i3 += 3), 16) : urlEncodedMessage.charCodeAt(i3++)) << (3 - (f3 & 3)) * 8;
  }
  dataSize = ((f3 + 7 >> 6) + 1) * BLOCK_SIZE_WORDS;
  data[dataSize - 1] = f3 * 8 - 8;
  for (; blockStartIndex < dataSize; blockStartIndex += BLOCK_SIZE_WORDS) {
    for (i3 = 0; i3 < 80; i3++) {
      f3 = rotl(a3, 5) + e3 + // Ch
      (i3 < 20 ? (b3 & c3 ^ ~b3 & d3) + 1518500249 : (
        // Parity
        i3 < 40 ? (b3 ^ c3 ^ d3) + 1859775393 : (
          // Maj
          i3 < 60 ? (b3 & c3 ^ b3 & d3 ^ c3 & d3) + 2400959708 : (
            // Parity
            (b3 ^ c3 ^ d3) + 3395469782
          )
        )
      )) + (hashBuffer[i3] = i3 < BLOCK_SIZE_WORDS ? data[blockStartIndex + i3] | 0 : rotl(hashBuffer[i3 - 3] ^ hashBuffer[i3 - 8] ^ hashBuffer[i3 - 14] ^ hashBuffer[i3 - 16], 1));
      e3 = d3;
      d3 = c3;
      c3 = rotl(b3, 30);
      b3 = a3;
      a3 = f3;
    }
    hash[0] = a3 = hash[0] + a3 | 0;
    hash[1] = b3 = hash[1] + b3 | 0;
    hash[2] = c3 = hash[2] + c3 | 0;
    hash[3] = d3 = hash[3] + d3 | 0;
    hash[4] = e3 = hash[4] + e3 | 0;
  }
  for (i3 = 0; i3 < HASH_SIZE_HALF_BYTES; i3++) {
    hexHash += // Get word (2^3 half-bytes per word)
    (hash[i3 >> 3] >>> // Append half-bytes in reverse order
    (7 - (i3 & 7)) * 4 & 15).toString(16);
  }
  return hexHash;
}
function isValidHash(hashCandidate) {
  return /^[0-9a-f]{11,}$/i.test(hashCandidate) && hashCandidate;
}
function computeHash(value) {
  return sha1(value == null ? "" : "" + value);
}
function svgValue(value) {
  return (value * 10 + 0.5 | 0) / 10;
}
var SvgPath = class {
  constructor() {
    this.v = "";
  }
  /**
   * Adds a polygon with the current fill color to the SVG path.
   * @param points An array of Point objects.
   */
  g(points) {
    let dataString = "";
    for (let i3 = 0; i3 < points.length; i3++) {
      dataString += (i3 ? "L" : "M") + svgValue(points[i3].x) + " " + svgValue(points[i3].y);
    }
    this.v += dataString + "Z";
  }
  /**
   * Adds a circle with the current fill color to the SVG path.
   * @param {Point} point The upper left corner of the circle bounding box.
   * @param {number} diameter The diameter of the circle.
   * @param {boolean} counterClockwise True if the circle is drawn counter-clockwise (will result in a hole if rendered on a clockwise path).
   */
  h(point, diameter, counterClockwise) {
    const sweepFlag = counterClockwise ? 0 : 1, svgRadius = svgValue(diameter / 2), svgDiameter = svgValue(diameter), svgArc = "a" + svgRadius + "," + svgRadius + " 0 1," + sweepFlag + " ";
    this.v += "M" + svgValue(point.x) + " " + svgValue(point.y + diameter / 2) + svgArc + svgDiameter + ",0" + svgArc + -svgDiameter + ",0";
  }
};
var SvgRenderer = class {
  /**
   * @param {SvgElement|SvgWriter} target 
   */
  constructor(target) {
    this.A;
    this.B = {};
    this.N = target;
    this.k = target.k;
  }
  /**
   * Fills the background with the specified color.
   * @param {string} fillColor  Fill color on the format #rrggbb[aa].
   */
  m(fillColor) {
    const match = /^(#......)(..)?/.exec(fillColor), opacity = match[2] ? parseHex(match[2], 0) / 255 : 1;
    this.N.m(match[1], opacity);
  }
  /**
   * Marks the beginning of a new shape of the specified color. Should be ended with a call to endShape.
   * @param {string} color Fill color on format #xxxxxx.
   */
  L(color) {
    this.A = this.B[color] || (this.B[color] = new SvgPath());
  }
  /**
   * Marks the end of the currently drawn shape.
   */
  M() {
  }
  /**
   * Adds a polygon with the current fill color to the SVG.
   * @param points An array of Point objects.
   */
  g(points) {
    this.A.g(points);
  }
  /**
   * Adds a circle with the current fill color to the SVG.
   * @param {Point} point The upper left corner of the circle bounding box.
   * @param {number} diameter The diameter of the circle.
   * @param {boolean} counterClockwise True if the circle is drawn counter-clockwise (will result in a hole if rendered on a clockwise path).
   */
  h(point, diameter, counterClockwise) {
    this.A.h(point, diameter, counterClockwise);
  }
  /**
   * Called when the icon has been completely drawn.
   */
  finish() {
    const pathsByColor = this.B;
    for (let color in pathsByColor) {
      if (pathsByColor.hasOwnProperty(color)) {
        this.N.O(
          color,
          pathsByColor[color].v
          /*dataString*/
        );
      }
    }
  }
};
var SVG_CONSTANTS = {
  P: "http://www.w3.org/2000/svg",
  R: "width",
  S: "height"
};
var SvgWriter = class {
  /**
   * @param {number} iconSize - Icon width and height in pixels.
   */
  constructor(iconSize) {
    this.k = iconSize;
    this.C = '<svg xmlns="' + SVG_CONSTANTS.P + '" width="' + iconSize + '" height="' + iconSize + '" viewBox="0 0 ' + iconSize + " " + iconSize + '">';
  }
  /**
   * Fills the background with the specified color.
   * @param {string} fillColor  Fill color on the format #rrggbb.
   * @param {number} opacity  Opacity in the range [0.0, 1.0].
   */
  m(fillColor, opacity) {
    if (opacity) {
      this.C += '<rect width="100%" height="100%" fill="' + fillColor + '" opacity="' + opacity.toFixed(2) + '"/>';
    }
  }
  /**
   * Writes a path to the SVG string.
   * @param {string} color Fill color on format #rrggbb.
   * @param {string} dataString The SVG path data string.
   */
  O(color, dataString) {
    this.C += '<path fill="' + color + '" d="' + dataString + '"/>';
  }
  /**
   * Gets the rendered image as an SVG string.
   */
  toString() {
    return this.C + "</svg>";
  }
};
function toSvg(hashOrValue, size, config) {
  const writer = new SvgWriter(size);
  iconGenerator(
    new SvgRenderer(writer),
    isValidHash(hashOrValue) || computeHash(hashOrValue),
    config
  );
  return writer.toString();
}
var documentQuerySelectorAll = (
  /** @type {!Function} */
  typeof document !== "undefined" && document.querySelectorAll.bind(document)
);

// node_modules/@polkadot/react-identicon/icons/Jdenticon.js
var import_react5 = __toESM(require_react(), 1);
function Identicon4({ className = "", publicKey, size, style }) {
  const html = (0, import_react5.useMemo)(() => ({ __html: toSvg(publicKey.substring(2), size) }), [publicKey, size]);
  return (0, import_jsx_runtime4.jsx)("div", { className, dangerouslySetInnerHTML: html, style });
}
var Jdenticon = import_react5.default.memo(Identicon4);

// node_modules/@polkadot/react-identicon/icons/Polkadot.js
var import_dist32 = __toESM(require_dist(), 1);
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var import_react6 = __toESM(require_react(), 1);
function renderCircle({ cx, cy, fill, r: r3 }, key) {
  return (0, import_jsx_runtime5.jsx)("circle", { cx, cy, fill, r: r3 }, key);
}
function Identicon5({ address, className = "", isAlternative = false, size, style }) {
  const circles = (0, import_react6.useMemo)(() => polkadotIcon(address, { isAlternative }), [address, isAlternative]);
  return (0, import_jsx_runtime5.jsx)("svg", { className, height: size, id: address, name: address, style, viewBox: "0 0 64 64", width: size, children: circles.map(renderCircle) });
}
var Polkadot = import_react6.default.memo(Identicon5);

// node_modules/@polkadot/react-identicon/Identicon.js
var import_dist53 = __toESM(require_dist(), 1);
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var import_react7 = __toESM(require_react(), 1);
var import_react_copy_to_clipboard = __toESM(require_lib(), 1);

// node_modules/@polkadot/ui-settings/index.js
var import_dist52 = __toESM(require_dist());

// node_modules/@polkadot/ui-settings/bundle.js
var import_dist51 = __toESM(require_dist(), 1);

// node_modules/@polkadot/ui-settings/Settings.js
var import_dist49 = __toESM(require_dist(), 1);
var import_store = __toESM(require_store_legacy(), 1);

// node_modules/@polkadot/ui-settings/defaults/index.js
var import_dist48 = __toESM(require_dist(), 1);

// node_modules/@polkadot/ui-settings/defaults/crypto.js
var import_dist34 = __toESM(require_dist(), 1);
var CRYPTOS = [
  {
    info: "sr25519",
    text: "Schnorrkel (sr25519, recommended)",
    value: "sr25519"
  },
  {
    info: "ed25519",
    text: "Edwards (ed25519, alternative)",
    value: "ed25519"
  },
  {
    info: "ecdsa",
    text: "ECDSA (Non BTC/ETH compatible)",
    value: "ecdsa"
  }
];
var CRYPTOS_ETH = [
  {
    info: "ethereum",
    text: "ECDSA (ETH compatible)",
    value: "ethereum"
  }
];
var CRYPTOS_LEDGER = [
  ...CRYPTOS,
  {
    info: "ed25519-ledger",
    text: "Ledger (ed25519, BIP32 derivation)",
    value: "ed25519-ledger"
  }
];

// node_modules/@polkadot/ui-settings/defaults/endpoints.js
var import_dist35 = __toESM(require_dist(), 1);
var ENDPOINTS = [{
  info: "local",
  text: "Local Node (Own, 127.0.0.1:9944)",
  value: "ws://127.0.0.1:9944/"
}];
var ENDPOINT_DEFAULT = ENDPOINTS[0];

// node_modules/@polkadot/ui-settings/defaults/ledger.js
var import_dist36 = __toESM(require_dist(), 1);
var LEDGER_CONN_DEFAULT = "none";
var LEDGER_CONN = [
  {
    info: "none",
    text: "Do not attach Ledger devices",
    value: "none"
  },
  // Deprecated
  // {
  //   info: 'u2f',
  //   text: 'Attach Ledger via U2F',
  //   value: 'u2f'
  // },
  {
    info: "webusb",
    text: "Attach Ledger via WebUSB (Chrome, recommended)",
    value: "webusb"
  },
  {
    info: "hid",
    text: "Attach Ledger via WebHID (Chrome, experimental)",
    value: "hid"
  }
];

// node_modules/@polkadot/ui-settings/defaults/ss58.js
var import_dist45 = __toESM(require_dist(), 1);

// node_modules/@polkadot/ui-settings/node_modules/@polkadot/networks/index.js
var import_dist44 = __toESM(require_dist());

// node_modules/@polkadot/ui-settings/node_modules/@polkadot/networks/interfaces.js
var import_dist42 = __toESM(require_dist(), 1);

// node_modules/@polkadot/ui-settings/node_modules/@polkadot/networks/defaults/index.js
var import_dist41 = __toESM(require_dist(), 1);

// node_modules/@polkadot/ui-settings/node_modules/@polkadot/networks/defaults/genesis.js
var import_dist37 = __toESM(require_dist(), 1);
var knownGenesis = {
  acala: [
    "0xfc41b9bd8ef8fe53d58c7ea67c794c7ec9a73daf05e6d54b14ff6342c99ba64c"
  ],
  ajuna: [
    "0xe358eb1d11b31255a286c12e44fe6780b7edb171d657905a97e39f71d9c6c3ee"
  ],
  "aleph-node": [
    "0x70255b4d28de0fc4e1a193d7e175ad1ccef431598211c55538f1018651a0344e"
  ],
  astar: [
    "0x9eb76c5184c4ab8679d2d5d819fdf90b9c001403e9e17da2e14b6d8aec4029c6"
  ],
  basilisk: [
    "0xa85cfb9b9fd4d622a5b28289a02347af987d8f73fa3108450e2b4a11c1ce5755"
  ],
  bifrost: [
    "0x262e1b2ad728475fd6fe88e62d34c200abe6fd693931ddad144059b1eb884e5b"
  ],
  "bifrost-kusama": [
    "0x9f28c6a68e0fc9646eff64935684f6eeeece527e37bbe1f213d22caa1d9d6bed"
  ],
  bittensor: [
    "0x2f0555cc76fc2840a25a6ea3b9637146806f1f44b090c175ffde2a7e5ab36c03"
  ],
  centrifuge: [
    "0xb3db41421702df9a7fcac62b53ffeac85f7853cc4e689e0b93aeb3db18c09d82",
    "0x67dddf2673b69e5f875f6f25277495834398eafd67f492e09f3f3345e003d1b5"
  ],
  composable: [
    "0xdaab8df776eb52ec604a5df5d388bb62a050a0aaec4556a64265b9d42755552d"
  ],
  darwinia: [
    "0xe71578b37a7c799b0ab4ee87ffa6f059a6b98f71f06fb8c84a8d88013a548ad6"
  ],
  "dock-mainnet": [
    "0x6bfe24dca2a3be10f22212678ac13a6446ec764103c0f3471c71609eac384aae",
    "0xf73467c6544aa68df2ee546b135f955c46b90fa627e9b5d7935f41061bb8a5a9"
  ],
  edgeware: [
    "0x742a2ca70c2fda6cee4f8df98d64c4c670a052d9568058982dad9d5a7a135c5b"
  ],
  equilibrium: [
    "0x6f1a800de3daff7f5e037ddf66ab22ce03ab91874debeddb1086f5f7dbd48925"
  ],
  genshiro: [
    "0x9b8cefc0eb5c568b527998bdd76c184e2b76ae561be76e4667072230217ea243"
  ],
  hydradx: [
    "0xafdc188f45c71dacbaa0b62e16a91f726c7b8699a9748cdf715459de6b7f366d",
    "0xd2a620c27ec5cbc5621ff9a522689895074f7cca0d08e7134a7804e1a3ba86fc",
    "0x10af6e84234477d84dc572bac0789813b254aa490767ed06fb9591191d1073f9",
    "0x3d75507dd46301767e601265791da1d9cb47b6ebc94e87347b635e5bf58bd047",
    "0x0ed32bfcab4a83517fac88f2aa7cbc2f88d3ab93be9a12b6188a036bf8a943c2"
    // Snakenet Gen1
  ],
  "interlay-parachain": [
    "0xbf88efe70e9e0e916416e8bed61f2b45717f517d7f3523e33c7b001e5ffcbc72"
  ],
  karura: [
    "0xbaf5aabe40646d11f0ee8abbdc64f4a4b7674925cba08e4a05ff9ebed6e2126b"
  ],
  khala: [
    "0xd43540ba6d3eb4897c28a77d48cb5b729fea37603cbbfc7a86a73b72adb3be8d"
  ],
  kulupu: [
    "0xf7a99d3cb92853d00d5275c971c132c074636256583fee53b3bbe60d7b8769ba"
  ],
  kusama: [
    "0xb0a8d493285c2df73290dfb7e61f870f17b41801197a149ca93654499ea3dafe",
    "0xe3777fa922cafbff200cadeaea1a76bd7898ad5b89f7848999058b50e715f636",
    "0x3fd7b9eb6a00376e5be61f01abb429ffb0b104be05eaff4d458da48fcd425baf"
    // Kusama CC1
  ],
  nodle: [
    "0x97da7ede98d7bad4e36b4d734b6055425a3be036da2a332ea5a7037656427a21"
  ],
  origintrail: [
    "0xe7e0962324a3b86c83404dbea483f25fb5dab4c224791c81b756cfc948006174"
  ],
  p3d: [
    "0x6c5894837ad89b6d92b114a2fb3eafa8fe3d26a54848e3447015442cd6ef4e66"
  ],
  parallel: [
    "0xe61a41c53f5dcd0beb09df93b34402aada44cb05117b71059cce40a2723a4e97"
  ],
  pendulum: [
    "0x5d3c298622d5634ed019bf61ea4b71655030015bde9beb0d6a24743714462c86"
  ],
  phala: [
    "0x1bb969d85965e4bb5a651abbedf21a54b6b31a21f66b5401cc3f1e286268d736"
  ],
  picasso: [
    "0x6811a339673c9daa897944dcdac99c6e2939cc88245ed21951a0a3c9a2be75bc",
    "0xe8e7f0f4c4f5a00720b4821dbfddefea7490bcf0b19009961cc46957984e2c1c"
  ],
  polkadex: [
    "0x3920bcb4960a1eef5580cd5367ff3f430eef052774f78468852f7b9cb39f8a3c"
  ],
  polkadot: [
    "0x91b171bb158e2d3848fa23a9f1c25182fb8e20313b2c1eb49219da7a70ce90c3"
  ],
  polymesh: [
    "0x6fbd74e5e1d0a61d52ccfe9d4adaed16dd3a7caa37c6bc4d0c2fa12e8b2f4063"
  ],
  rococo: [
    "0x6408de7737c59c238890533af25896a2c20608d8b380bb01029acb392781063e",
    "0xaaf2cd1b74b5f726895921259421b534124726263982522174147046b8827897",
    "0x037f5f3c8e67b314062025fc886fcd6238ea25a4a9b45dce8d246815c9ebe770",
    "0xc196f81260cf1686172b47a79cf002120735d7cb0eb1474e8adce56618456fff",
    "0xf6e9983c37baf68846fedafe21e56718790e39fb1c582abc408b81bc7b208f9a",
    "0x5fce687da39305dfe682b117f0820b319348e8bb37eb16cf34acbf6a202de9d9",
    "0xe7c3d5edde7db964317cd9b51a3a059d7cd99f81bdbce14990047354334c9779",
    "0x1611e1dbf0405379b861e2e27daa90f480b2e6d3682414a80835a52e8cb8a215",
    "0x343442f12fa715489a8714e79a7b264ea88c0d5b8c66b684a7788a516032f6b9",
    "0x78bcd530c6b3a068bc17473cf5d2aff9c287102bed9af3ae3c41c33b9d6c6147",
    "0x47381ee0697153d64404fc578392c8fd5cba9073391908f46c888498415647bd",
    "0x19c0e4fa8ab75f5ac7865e0b8f74ff91eb9a100d336f423cd013a8befba40299"
  ],
  sora: [
    "0x7e4e32d0feafd4f9c9414b0be86373f9a1efa904809b683453a9af6856d38ad5"
  ],
  stafi: [
    "0x290a4149f09ea0e402c74c1c7e96ae4239588577fe78932f94f5404c68243d80"
  ],
  statemine: [
    "0x48239ef607d7928874027a43a67689209727dfb3d3dc5e5b03a39bdc2eda771a"
  ],
  statemint: [
    "0x68d56f15f85d3136970ec16946040bc1752654e906147f7e43e9d539d7c3de2f"
  ],
  subsocial: [
    "0x0bd72c1c305172e1275278aaeb3f161e02eccb7a819e63f62d47bd53a28189f8"
  ],
  ternoa: [
    "0x6859c81ca95ef624c9dfe4dc6e3381c33e5d6509e35e147092bfbc780f777c4e"
  ],
  unique: [
    "0x84322d9cddbf35088f1e54e9a85c967a41a56a4f43445768125e61af166c7d31"
  ],
  vtb: [
    "0x286bc8414c7000ce1d6ee6a834e29a54c1784814b76243eb77ed0b2c5573c60f",
    "0x7483b89572fb2bd687c7b9a93b242d0b237f9aba463aba07ec24503931038aaa"
  ],
  westend: [
    "0xe143f23803ac50e8f6f8e62695d1ce9e4e1d68aa36c1cd2cfd15340213f3423e"
  ],
  xxnetwork: [
    "0x50dd5d206917bf10502c68fb4d18a59fc8aa31586f4e8856b493e43544aa82aa"
  ]
};

// node_modules/@polkadot/ui-settings/node_modules/@polkadot/networks/defaults/icons.js
var import_dist38 = __toESM(require_dist(), 1);
var knownIcon = {
  centrifuge: "polkadot",
  kusama: "polkadot",
  polkadot: "polkadot",
  sora: "polkadot",
  statemine: "polkadot",
  statemint: "polkadot",
  westmint: "polkadot"
};

// node_modules/@polkadot/ui-settings/node_modules/@polkadot/networks/defaults/ledger.js
var import_dist39 = __toESM(require_dist(), 1);
var knownLedger = {
  acala: 787,
  ajuna: 354,
  "aleph-node": 643,
  astar: 810,
  bifrost: 788,
  "bifrost-kusama": 788,
  centrifuge: 747,
  composable: 354,
  darwinia: 354,
  "dock-mainnet": 594,
  edgeware: 523,
  equilibrium: 99999997,
  genshiro: 99999996,
  hydradx: 354,
  "interlay-parachain": 354,
  karura: 686,
  khala: 434,
  kusama: 434,
  nodle: 1003,
  origintrail: 354,
  parallel: 354,
  pendulum: 354,
  phala: 354,
  picasso: 434,
  polkadex: 799,
  polkadot: 354,
  polymesh: 595,
  sora: 617,
  stafi: 907,
  statemine: 434,
  statemint: 354,
  ternoa: 995,
  unique: 354,
  vtb: 694,
  xxnetwork: 1955
};

// node_modules/@polkadot/ui-settings/node_modules/@polkadot/networks/defaults/testnets.js
var import_dist40 = __toESM(require_dist(), 1);
var knownTestnet = {
  "": true,
  "cess-testnet": true,
  "dock-testnet": true,
  jupiter: true,
  "mathchain-testnet": true,
  p3dt: true,
  subspace_testnet: true,
  "zero-alphaville": true
};

// node_modules/@polkadot/ui-settings/node_modules/@polkadot/networks/interfaces.js
var UNSORTED = [0, 2, 42];
var TESTNETS = ["testnet"];
function toExpanded(o3) {
  const network = o3.network || "";
  const nameParts = network.replace(/_/g, "-").split("-");
  const n3 = o3;
  n3.slip44 = knownLedger[network];
  n3.hasLedgerSupport = !!n3.slip44;
  n3.genesisHash = knownGenesis[network] || [];
  n3.icon = knownIcon[network] || "substrate";
  n3.isTestnet = !!knownTestnet[network] || TESTNETS.includes(nameParts[nameParts.length - 1]);
  n3.isIgnored = n3.isTestnet || !(o3.standardAccount && o3.decimals && o3.decimals.length && o3.symbols && o3.symbols.length) && o3.prefix !== 42;
  return n3;
}
function filterSelectable({ genesisHash, prefix }) {
  return !!genesisHash.length || prefix === 42;
}
function filterAvailable(n3) {
  return !n3.isIgnored && !!n3.network;
}
function sortNetworks(a3, b3) {
  const isUnSortedA = UNSORTED.includes(a3.prefix);
  const isUnSortedB = UNSORTED.includes(b3.prefix);
  return isUnSortedA === isUnSortedB ? isUnSortedA ? 0 : a3.displayName.localeCompare(b3.displayName) : isUnSortedA ? -1 : 1;
}
var allNetworks = esm_default.map(toExpanded);
var availableNetworks = allNetworks.filter(filterAvailable).sort(sortNetworks);
var selectableNetworks = availableNetworks.filter(filterSelectable);

// node_modules/@polkadot/ui-settings/node_modules/@polkadot/networks/packageInfo.js
var import_dist43 = __toESM(require_dist(), 1);
var packageInfo4 = { name: "@polkadot/networks", path: import.meta && import.meta.url ? new URL(import.meta.url).pathname.substring(0, new URL(import.meta.url).pathname.lastIndexOf("/") + 1) : "auto", type: "esm", version: "11.1.3" };

// node_modules/@polkadot/ui-settings/defaults/ss58.js
var PREFIX_DEFAULT = -1;
var defaultNetwork = {
  info: "default",
  text: "Default for the connected node",
  value: -1
};
var networks = availableNetworks.map(({ displayName, network, prefix }) => ({
  info: network,
  text: displayName,
  value: prefix
}));
var PREFIXES = [defaultNetwork, ...networks];

// node_modules/@polkadot/ui-settings/defaults/ui.js
var import_dist47 = __toESM(require_dist(), 1);

// node_modules/@polkadot/ui-settings/defaults/type.js
var import_dist46 = __toESM(require_dist(), 1);
var isPolkadot = typeof window !== "undefined" && window.location.host.includes("polkadot");

// node_modules/@polkadot/ui-settings/defaults/ui.js
var UIMODE_DEFAULT = !isPolkadot && typeof window !== "undefined" && window.location.host.includes("ui-light") ? "light" : "full";
var UIMODES = [
  {
    info: "full",
    text: "Fully featured",
    value: "full"
  },
  {
    info: "light",
    text: "Basic features only",
    value: "light"
  }
];
var UITHEME_DEFAULT = isPolkadot ? "polkadot" : "substrate";
var UITHEMES = [
  {
    info: "polkadot",
    text: "Polkadot",
    value: "polkadot"
  },
  {
    info: "substrate",
    text: "Substrate",
    value: "substrate"
  }
];
var ICON_DEFAULT = "default";
var ICON_DEFAULT_HOST = isPolkadot ? "polkadot" : "substrate";
var ICONS = [
  {
    info: "default",
    text: "Default for the connected node",
    value: "default"
  },
  {
    info: "polkadot",
    text: "Polkadot",
    value: "polkadot"
  },
  {
    info: "substrate",
    text: "Substrate",
    value: "substrate"
  },
  {
    info: "beachball",
    text: "Beachball",
    value: "beachball"
  }
];
var NOTIFICATION_DEFAULT = "popup";

// node_modules/@polkadot/ui-settings/defaults/index.js
var CAMERA_DEFAULT = "off";
var CAMERA = [
  {
    info: "on",
    text: "Allow camera access",
    value: "on"
  },
  {
    info: "off",
    text: "Do not allow camera access",
    value: "off"
  }
];
var LANGUAGE_DEFAULT = "default";
var LOCKING_DEFAULT = "session";
var LOCKING = [
  {
    info: "session",
    text: "Once per session",
    value: "session"
  },
  {
    info: "tx",
    text: "On each transaction",
    value: "tx"
  }
];
var METADATA_UP_DEFAULT = "off";
var METADATA_UP = [
  {
    info: "off",
    text: "Do not auto-update extension metadata",
    value: "off"
  },
  {
    info: "on",
    text: "Auto-update extension metadata",
    value: "on"
  }
];
var STORAGE_DEFAULT = "off";
var STORAGE = [
  {
    info: "on",
    text: "Allow local in-browser account storage",
    value: "on"
  },
  {
    info: "off",
    text: "Do not allow local in-browser account storage",
    value: "off"
  }
];

// node_modules/@polkadot/ui-settings/Settings.js
var _Settings_emitter;
var _Settings_apiType;
var _Settings_apiUrl;
var _Settings_camera;
var _Settings_i18nLang;
var _Settings_icon;
var _Settings_ledgerConn;
var _Settings_locking;
var _Settings_metadataUp;
var _Settings_prefix;
var _Settings_storage;
var _Settings_uiMode;
var _Settings_uiTheme;
var _Settings_notification;
function withDefault(options, option, fallback) {
  const _option = option || fallback;
  return options.some(({ value }) => value === _option) ? _option : fallback;
}
var Settings = class {
  constructor() {
    _Settings_emitter.set(this, void 0);
    _Settings_apiType.set(this, void 0);
    _Settings_apiUrl.set(this, void 0);
    _Settings_camera.set(this, void 0);
    _Settings_i18nLang.set(this, void 0);
    _Settings_icon.set(this, void 0);
    _Settings_ledgerConn.set(this, void 0);
    _Settings_locking.set(this, void 0);
    _Settings_metadataUp.set(this, void 0);
    _Settings_prefix.set(this, void 0);
    _Settings_storage.set(this, void 0);
    _Settings_uiMode.set(this, void 0);
    _Settings_uiTheme.set(this, void 0);
    _Settings_notification.set(this, void 0);
    const settings2 = import_store.default.get("settings") || {};
    __classPrivateFieldSet(this, _Settings_emitter, new import_index.default(), "f");
    __classPrivateFieldSet(this, _Settings_apiUrl, typeof settings2.apiUrl === "string" && settings2.apiUrl || hasProcess && process.env && process.env.WS_URL || ENDPOINT_DEFAULT.value, "f");
    __classPrivateFieldSet(this, _Settings_apiType, { param: __classPrivateFieldGet(this, _Settings_apiUrl, "f"), type: "json-rpc" }, "f");
    __classPrivateFieldSet(this, _Settings_camera, withDefault(CAMERA, settings2.camera, CAMERA_DEFAULT), "f");
    __classPrivateFieldSet(this, _Settings_ledgerConn, withDefault(LEDGER_CONN, settings2.ledgerConn, LEDGER_CONN_DEFAULT), "f");
    __classPrivateFieldSet(this, _Settings_i18nLang, settings2.i18nLang || LANGUAGE_DEFAULT, "f");
    __classPrivateFieldSet(this, _Settings_icon, settings2.icon || ICON_DEFAULT, "f");
    __classPrivateFieldSet(this, _Settings_locking, settings2.locking || LOCKING_DEFAULT, "f");
    __classPrivateFieldSet(this, _Settings_metadataUp, withDefault(METADATA_UP, settings2.storage, METADATA_UP_DEFAULT), "f");
    __classPrivateFieldSet(this, _Settings_notification, settings2.notification || NOTIFICATION_DEFAULT, "f");
    __classPrivateFieldSet(this, _Settings_prefix, isUndefined(settings2.prefix) ? PREFIX_DEFAULT : settings2.prefix, "f");
    __classPrivateFieldSet(this, _Settings_storage, withDefault(STORAGE, settings2.storage, STORAGE_DEFAULT), "f");
    __classPrivateFieldSet(this, _Settings_uiMode, settings2.uiMode || UIMODE_DEFAULT, "f");
    __classPrivateFieldSet(this, _Settings_uiTheme, settings2.uiTheme || UITHEME_DEFAULT, "f");
  }
  get camera() {
    return __classPrivateFieldGet(this, _Settings_camera, "f");
  }
  get apiType() {
    return __classPrivateFieldGet(this, _Settings_apiType, "f");
  }
  get apiUrl() {
    return __classPrivateFieldGet(this, _Settings_apiUrl, "f");
  }
  get i18nLang() {
    return __classPrivateFieldGet(this, _Settings_i18nLang, "f");
  }
  get icon() {
    return __classPrivateFieldGet(this, _Settings_icon, "f");
  }
  get notification() {
    return __classPrivateFieldGet(this, _Settings_notification, "f");
  }
  get ledgerConn() {
    return __classPrivateFieldGet(this, _Settings_ledgerConn, "f");
  }
  get locking() {
    return __classPrivateFieldGet(this, _Settings_locking, "f");
  }
  get metadataUp() {
    return __classPrivateFieldGet(this, _Settings_metadataUp, "f");
  }
  get prefix() {
    return __classPrivateFieldGet(this, _Settings_prefix, "f");
  }
  get storage() {
    return __classPrivateFieldGet(this, _Settings_storage, "f");
  }
  get uiMode() {
    return __classPrivateFieldGet(this, _Settings_uiMode, "f");
  }
  get uiTheme() {
    return __classPrivateFieldGet(this, _Settings_uiTheme, "f");
  }
  get availableCamera() {
    return CAMERA;
  }
  get availableCryptos() {
    return CRYPTOS;
  }
  get availableCryptosEth() {
    return CRYPTOS_ETH;
  }
  get availableCryptosLedger() {
    return CRYPTOS_LEDGER;
  }
  get availableIcons() {
    return ICONS;
  }
  get availableLedgerConn() {
    return LEDGER_CONN;
  }
  get availableLocking() {
    return LOCKING;
  }
  get availableMetadataUp() {
    return METADATA_UP;
  }
  get availableNodes() {
    return ENDPOINTS;
  }
  get availablePrefixes() {
    return PREFIXES;
  }
  get availableStorage() {
    return STORAGE;
  }
  get availableUIModes() {
    return UIMODES;
  }
  get availableUIThemes() {
    return UITHEMES;
  }
  get() {
    return {
      apiType: __classPrivateFieldGet(this, _Settings_apiType, "f"),
      apiUrl: __classPrivateFieldGet(this, _Settings_apiUrl, "f"),
      camera: __classPrivateFieldGet(this, _Settings_camera, "f"),
      i18nLang: __classPrivateFieldGet(this, _Settings_i18nLang, "f"),
      icon: __classPrivateFieldGet(this, _Settings_icon, "f"),
      ledgerConn: __classPrivateFieldGet(this, _Settings_ledgerConn, "f"),
      locking: __classPrivateFieldGet(this, _Settings_locking, "f"),
      metadataUp: __classPrivateFieldGet(this, _Settings_metadataUp, "f"),
      notification: __classPrivateFieldGet(this, _Settings_notification, "f"),
      prefix: __classPrivateFieldGet(this, _Settings_prefix, "f"),
      storage: __classPrivateFieldGet(this, _Settings_storage, "f"),
      uiMode: __classPrivateFieldGet(this, _Settings_uiMode, "f"),
      uiTheme: __classPrivateFieldGet(this, _Settings_uiTheme, "f")
    };
  }
  set(settings2) {
    __classPrivateFieldSet(this, _Settings_apiType, settings2.apiType || __classPrivateFieldGet(this, _Settings_apiType, "f"), "f");
    __classPrivateFieldSet(this, _Settings_apiUrl, settings2.apiUrl || __classPrivateFieldGet(this, _Settings_apiUrl, "f"), "f");
    __classPrivateFieldSet(this, _Settings_camera, settings2.camera || __classPrivateFieldGet(this, _Settings_camera, "f"), "f");
    __classPrivateFieldSet(this, _Settings_ledgerConn, settings2.ledgerConn || __classPrivateFieldGet(this, _Settings_ledgerConn, "f"), "f");
    __classPrivateFieldSet(this, _Settings_i18nLang, settings2.i18nLang || __classPrivateFieldGet(this, _Settings_i18nLang, "f"), "f");
    __classPrivateFieldSet(this, _Settings_icon, settings2.icon || __classPrivateFieldGet(this, _Settings_icon, "f"), "f");
    __classPrivateFieldSet(this, _Settings_locking, settings2.locking || __classPrivateFieldGet(this, _Settings_locking, "f"), "f");
    __classPrivateFieldSet(this, _Settings_metadataUp, settings2.metadataUp || __classPrivateFieldGet(this, _Settings_metadataUp, "f"), "f");
    __classPrivateFieldSet(this, _Settings_notification, settings2.notification || __classPrivateFieldGet(this, _Settings_notification, "f"), "f");
    __classPrivateFieldSet(this, _Settings_prefix, isUndefined(settings2.prefix) ? __classPrivateFieldGet(this, _Settings_prefix, "f") : settings2.prefix, "f");
    __classPrivateFieldSet(this, _Settings_storage, settings2.storage || __classPrivateFieldGet(this, _Settings_storage, "f"), "f");
    __classPrivateFieldSet(this, _Settings_uiMode, settings2.uiMode || __classPrivateFieldGet(this, _Settings_uiMode, "f"), "f");
    __classPrivateFieldSet(this, _Settings_uiTheme, settings2.uiTheme || __classPrivateFieldGet(this, _Settings_uiTheme, "f"), "f");
    const newValues = this.get();
    import_store.default.set("settings", newValues);
    __classPrivateFieldGet(this, _Settings_emitter, "f").emit("change", newValues);
  }
  on(type, cb) {
    __classPrivateFieldGet(this, _Settings_emitter, "f").on(type, cb);
  }
};
_Settings_emitter = /* @__PURE__ */ new WeakMap(), _Settings_apiType = /* @__PURE__ */ new WeakMap(), _Settings_apiUrl = /* @__PURE__ */ new WeakMap(), _Settings_camera = /* @__PURE__ */ new WeakMap(), _Settings_i18nLang = /* @__PURE__ */ new WeakMap(), _Settings_icon = /* @__PURE__ */ new WeakMap(), _Settings_ledgerConn = /* @__PURE__ */ new WeakMap(), _Settings_locking = /* @__PURE__ */ new WeakMap(), _Settings_metadataUp = /* @__PURE__ */ new WeakMap(), _Settings_prefix = /* @__PURE__ */ new WeakMap(), _Settings_storage = /* @__PURE__ */ new WeakMap(), _Settings_uiMode = /* @__PURE__ */ new WeakMap(), _Settings_uiTheme = /* @__PURE__ */ new WeakMap(), _Settings_notification = /* @__PURE__ */ new WeakMap();
var settings = new Settings();

// node_modules/@polkadot/ui-settings/defaults/chains.js
var import_dist50 = __toESM(require_dist(), 1);
var chains = selectableNetworks.filter((n3) => n3.genesisHash.length).reduce((chains2, { genesisHash, network }) => objectSpread(chains2, { [network]: genesisHash }), {});

// node_modules/@polkadot/react-identicon/Identicon.js
var styled2 = styled_components_browser_esm_default.styled || styled_components_browser_esm_default.default || styled_components_browser_esm_default;
var Fallback = Beachball;
var DEFAULT_SIZE = 64;
var Components = {
  beachball: Beachball,
  empty: Empty,
  ethereum: Ethereum,
  jdenticon: Jdenticon,
  polkadot: Polkadot,
  substrate: Jdenticon
};
var BaseIcon = class _BaseIcon extends import_react7.default.PureComponent {
  constructor() {
    super(...arguments);
    this.state = {
      address: "",
      publicKey: "0x"
    };
    this.onCopy = () => {
      const { onCopy } = this.props;
      const { address } = this.state;
      if (address && onCopy) {
        onCopy(address);
      }
    };
  }
  static setDefaultPrefix(prefix) {
    _BaseIcon.prefix = prefix;
  }
  static getDerivedStateFromProps({ prefix = _BaseIcon.prefix, theme, value }, prevState) {
    if (theme === "ethereum") {
      const address = isU8a(value) ? ethereumEncode(value) : value || "";
      return { address, publicKey: "" };
    }
    try {
      const address = isU8a(value) || isHex(value) ? encodeAddress(value, prefix) : value || "";
      const publicKey = u8aToHex(decodeAddress(address, false, prefix));
      return address === prevState.address ? null : {
        address,
        publicKey
      };
    } catch {
      return {
        address: "",
        publicKey: "0x"
      };
    }
  }
  render() {
    const { address } = this.state;
    const wrapped = this.getWrapped(this.state, this.props);
    return !address ? wrapped : (0, import_jsx_runtime6.jsx)(import_react_copy_to_clipboard.default, { onCopy: this.onCopy, text: address, children: wrapped });
  }
  getWrapped({ address, publicKey }, { Custom }) {
    const { className = "", isAlternative, isHighlight, size = DEFAULT_SIZE, style, theme = settings.icon } = this.props;
    const Component = !address ? Empty : Custom || Components[theme === "default" ? ICON_DEFAULT_HOST : theme] || Fallback;
    return (0, import_jsx_runtime6.jsx)(StyledDiv, { className: `ui--IdentityIcon  ${className}`, style, children: (0, import_jsx_runtime6.jsx)(Component, { address, className: isHighlight ? "highlight" : "", isAlternative, publicKey, size }) }, address);
  }
};
BaseIcon.prefix = void 0;
function Icon(props) {
  return (0, import_jsx_runtime6.jsx)(BaseIcon, { ...props });
}
var StyledDiv = styled2.div`
  cursor: copy;
  display: inline-block;
  line-height: 0;

  > .container {
    position: relative;

    > div,
    > svg {
      position: relative;
    }

    &.highlight:before {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      border-radius: 50%;
      box-shadow: 0 0 5px 2px #aaa;
      content: '';
    }
  }
`;
var Identicon6 = import_react7.default.memo(Icon);

// node_modules/@polkadot/react-identicon/index.js
var react_identicon_default = Identicon6;
export {
  Beachball,
  Empty,
  Ethereum,
  Identicon6 as Identicon,
  Jdenticon,
  Polkadot,
  react_identicon_default as default,
  packageInfo3 as packageInfo
};
/*! Bundled license information:

ethereum-blockies-base64/dist/main.js:
  (**
   * A handy class to calculate color values.
   *
   * @version 1.0
   * @author Robert Eisele <robert@xarg.org>
   * @copyright Copyright (c) 2010, Robert Eisele
   * @link http://www.xarg.org/2010/03/generate-client-side-png-files-using-javascript/
   * @license http://www.opensource.org/licenses/bsd-license.php BSD License
   *
   *)

react-is/cjs/react-is.production.min.js:
  (** @license React v16.13.1
   * react-is.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-is/cjs/react-is.development.js:
  (** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=@polkadot_react-identicon.js.map
